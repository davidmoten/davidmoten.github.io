<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Http.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">openapi-codegen-http</a> &gt; <a href="index.source.html" class="el_package">org.davidmoten.oa3.codegen.http</a> &gt; <span class="el_source">Http.java</span></div><h1>Http.java</h1><pre class="source lang-java linenums">package org.davidmoten.oa3.codegen.http;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

import org.davidmoten.oa3.codegen.util.Util;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.exc.StreamReadException;
import com.fasterxml.jackson.databind.DatabindException;
import com.github.davidmoten.guavamini.Preconditions;
import com.github.davidmoten.guavamini.annotations.VisibleForTesting;

<span class="nc" id="L33">public final class Http {</span>

<span class="fc" id="L35">    private static Logger log = LoggerFactory.getLogger(Http.class);</span>

    public static Builder method(HttpMethod method) {
<span class="fc" id="L38">        return new Builder(method);</span>
    }

    public static final class Builder {

        private final HttpMethod method;
        private String basePath;
        private String path;
<span class="fc" id="L46">        private final Headers headers = Headers.create();</span>
<span class="fc" id="L47">        private final List&lt;ParameterValue&gt; values = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L48">        private final List&lt;ResponseDescriptor&gt; responseDescriptors = new ArrayList&lt;&gt;();</span>
        private Serializer serializer;
<span class="fc" id="L50">        private List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L51">        private boolean allowPatch = false;</span>

<span class="fc" id="L53">        Builder(HttpMethod method) {</span>
<span class="fc" id="L54">            this.method = method;</span>
<span class="fc" id="L55">        }</span>

        public BuilderWithBasePath basePath(String basePath) {
<span class="fc" id="L58">            this.basePath = basePath;</span>
<span class="fc" id="L59">            return new BuilderWithBasePath(this);</span>
        }

        public Builder header(String key, Object value) {
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">            if (&quot;CONTENT-TYPE&quot;.equals(key.toUpperCase(Locale.ENGLISH))) {</span>
<span class="nc" id="L64">                throw new IllegalArgumentException(&quot;set content type in the builder just after setting the body&quot;);</span>
            }
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">            if (value != null) {</span>
<span class="fc" id="L67">                headers.put(key, value.toString());</span>
            }
<span class="fc" id="L69">            return this;</span>
        }

        public Builder header(String key, Optional&lt;?&gt; value) {
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (value.isPresent()) {</span>
<span class="nc" id="L74">                return header(key, value.get());</span>
            } else {
<span class="nc" id="L76">                return this;</span>
            }
        }

        public Builder allowPatch() {
<span class="nc" id="L81">            return allowPatch(true);</span>
        }

        private Builder allowPatch(boolean allowPatch) {
<span class="nc" id="L85">            this.allowPatch = allowPatch;</span>
<span class="nc" id="L86">            return this;</span>
        }

        public Builder interceptor(Interceptor interceptor) {
<span class="nc" id="L90">            this.interceptors.add(interceptor);</span>
<span class="nc" id="L91">            return this;</span>
        }

        public Builder interceptors(Iterable&lt;? extends Interceptor&gt; list) {
<span class="nc" id="L95">            interceptors.forEach(x -&gt; interceptor(x));</span>
<span class="nc" id="L96">            return this;</span>
        }

        public Builder acceptApplicationJson() {
<span class="fc" id="L100">            return header(&quot;Accept&quot;, &quot;application/json&quot;);</span>
        }

        public Builder acceptAny() {
<span class="nc" id="L104">            return header(&quot;Accept&quot;, &quot;*/*&quot;);</span>
        }

        public Builder param(String name, Optional&lt;Object&gt; value, ParameterType type, Optional&lt;String&gt; contentType) {
<span class="nc" id="L108">            values.add(new ParameterValue(name, value, type, contentType));</span>
<span class="nc" id="L109">            return this;</span>
        }

        public Builder queryParam(String name, Optional&lt;?&gt; value) {
<span class="nc" id="L113">            values.add(ParameterValue.query(name, value));</span>
<span class="nc" id="L114">            return this;</span>
        }

        public Builder queryParam(String name, Object value) {
<span class="fc" id="L118">            values.add(ParameterValue.query(name, value));</span>
<span class="fc" id="L119">            return this;</span>
        }

        public Builder pathParam(String name, Optional&lt;?&gt; value) {
<span class="nc" id="L123">            values.add(ParameterValue.path(name, value));</span>
<span class="nc" id="L124">            return this;</span>
        }

        public Builder pathParam(String name, Object value) {
<span class="nc" id="L128">            values.add(ParameterValue.path(name, value));</span>
<span class="nc" id="L129">            return this;</span>
        }

        public Builder cookie(String name, Object value) {
<span class="nc" id="L133">            values.add(ParameterValue.cookie(name, value));</span>
<span class="nc" id="L134">            return this;</span>
        }

        public BuilderWithBody body(Object value) {
<span class="fc" id="L138">            return new BuilderWithBody(this, value);</span>
        }

        public BuilderWithReponseDescriptor responseAs(Class&lt;?&gt; cls) {
<span class="fc" id="L142">            return new BuilderWithReponseDescriptor(this, cls);</span>
        }

        public HttpResponse call() {
<span class="fc" id="L146">            return Http.call(method, basePath, path, serializer, interceptors, headers, values, responseDescriptors,</span>
                    allowPatch);
        }

    }

    public static final class BuilderWithBasePath {

        private final Builder b;

<span class="fc" id="L156">        BuilderWithBasePath(Builder b) {</span>
<span class="fc" id="L157">            this.b = b;</span>
<span class="fc" id="L158">        }</span>

        public BuilderWithPath path(String path) {
<span class="fc" id="L161">            b.path = path;</span>
<span class="fc" id="L162">            return new BuilderWithPath(b);</span>
        }
    }

    public static final class BuilderWithPath {

        private final Builder b;

<span class="fc" id="L170">        BuilderWithPath(Builder b) {</span>
<span class="fc" id="L171">            this.b = b;</span>
<span class="fc" id="L172">        }</span>

        public Builder serializer(Serializer serializer) {
<span class="fc" id="L175">            b.serializer = serializer;</span>
<span class="fc" id="L176">            return b;</span>
        }
    }

    public static final class BuilderWithBody {

        private final Builder b;
        private final Object body;

<span class="fc" id="L185">        BuilderWithBody(Builder b, Object body) {</span>
<span class="fc" id="L186">            this.b = b;</span>
<span class="fc" id="L187">            this.body = body;</span>
<span class="fc" id="L188">        }</span>

        public Builder contentType(String value) {
<span class="fc" id="L191">            b.values.add(ParameterValue.body(body, value));</span>
<span class="fc" id="L192">            return b;</span>
        }

        public Builder contentTypeApplicationJson() {
<span class="fc" id="L196">            return contentType(&quot;application/json&quot;);</span>
        }

    }

    public static final class BuilderWithReponseDescriptor {

        private final Builder b;
        private String statusCode;
        private Class&lt;?&gt; cls;

<span class="fc" id="L207">        BuilderWithReponseDescriptor(Builder b, Class&lt;?&gt; cls) {</span>
<span class="fc" id="L208">            this.b = b;</span>
<span class="fc" id="L209">            this.cls = cls;</span>
<span class="fc" id="L210">        }</span>

        public BuilderWithStatusCodeMatch whenStatusCodeMatches(String statusCode) {
<span class="fc" id="L213">            this.statusCode = statusCode;</span>
<span class="fc" id="L214">            return new BuilderWithStatusCodeMatch(this);</span>
        }

        public BuilderWithStatusCodeMatch whenStatusCodeDefault() {
<span class="fc" id="L218">            this.statusCode = &quot;default&quot;;</span>
<span class="fc" id="L219">            return new BuilderWithStatusCodeMatch(this);</span>
        }

    }

    public static final class BuilderWithStatusCodeMatch {

        private final BuilderWithReponseDescriptor brd;

<span class="fc" id="L228">        public BuilderWithStatusCodeMatch(BuilderWithReponseDescriptor brd) {</span>
<span class="fc" id="L229">            this.brd = brd;</span>
<span class="fc" id="L230">        }</span>

        public Builder whenContentTypeMatches(String contentType) {
<span class="fc" id="L233">            brd.b.responseDescriptors.add(new ResponseDescriptor(brd.statusCode, contentType, brd.cls));</span>
<span class="fc" id="L234">            return brd.b;</span>
        }

    }

    public static HttpResponse call(//
            HttpMethod method, //
            String basePath, //
            String pathTemplate, //
            Serializer serializer, //
            List&lt;Interceptor&gt; interceptors, //
            Headers requestHeaders, //
            List&lt;ParameterValue&gt; parameters, //
            // (statusCode, contentType, class)
            List&lt;ResponseDescriptor&gt; descriptors, boolean allowPatch) {
<span class="fc" id="L249">        return call(method, basePath, pathTemplate, serializer, interceptors, requestHeaders, parameters,</span>
<span class="fc" id="L250">                (statusCode, contentType) -&gt; match(descriptors, statusCode, contentType), allowPatch);</span>
    }

    private static Optional&lt;Class&lt;?&gt;&gt; match(List&lt;ResponseDescriptor&gt; descriptors, Integer statusCode,
            String contentType) {
<span class="fc" id="L255">        List&lt;ResponseDescriptor&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (ResponseDescriptor d : descriptors) {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (d.matches(statusCode, contentType)) {</span>
<span class="fc" id="L258">                matches.add(d);</span>
            }
<span class="fc" id="L260">        }</span>
<span class="fc" id="L261">        Collections.sort(matches, ResponseDescriptor.specificity());</span>
<span class="fc" id="L262">        return matches.stream().findFirst().map(d -&gt; d.cls());</span>
    }

    private static HttpResponse call(//
            HttpMethod method, //
            String basePath, //
            String pathTemplate, //
            Serializer serializer, //
            List&lt;Interceptor&gt; interceptors, //
            Headers requestHeaders, //
            List&lt;ParameterValue&gt; parameters, //
            // (statusCode x contentType) -&gt; class
            BiFunction&lt;? super Integer, ? super String, Optional&lt;Class&lt;?&gt;&gt;&gt; responseCls, boolean allowPatch) {
<span class="fc" id="L275">        String url = buildUrl(basePath, pathTemplate, parameters);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        Optional&lt;ParameterValue&gt; requestBody = parameters.stream().filter(x -&gt; x.type() == ParameterType.BODY)</span>
<span class="fc" id="L277">                .findFirst();</span>
        try {
<span class="fc" id="L279">            Headers headers = new Headers(requestHeaders);</span>
            final HttpMethod requestMethod;
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">            if (!allowPatch &amp;&amp; method.equals(HttpMethod.PATCH)) {</span>
<span class="nc" id="L282">                headers.put(&quot;X-HTTP-Method-Override&quot;, HttpMethod.PATCH.name());</span>
<span class="nc" id="L283">                requestMethod = HttpMethod.POST;</span>
            } else {
<span class="fc" id="L285">                requestMethod = method;</span>
            }
            // modify request metadata (like insert auth related headers)
<span class="fc" id="L288">            RequestBase r = new RequestBase(requestMethod, url, headers);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            for (Interceptor interceptor : interceptors) {</span>
<span class="nc" id="L290">                r = interceptor.intercept(r);</span>
<span class="nc" id="L291">            }</span>
<span class="fc" id="L292">            log.debug(&quot;connecting to method=&quot; + r.method() + &quot;, url=&quot; + url + &quot;, headers=&quot; + r.headers());</span>
<span class="fc" id="L293">            return connectAndProcess(serializer, parameters, responseCls, r.url(), requestBody, r.headers(),</span>
<span class="fc" id="L294">                    r.method());</span>
<span class="nc" id="L295">        } catch (IOException e) {</span>
<span class="nc" id="L296">            throw new UncheckedIOException(e);</span>
        }
    }

    private static HttpResponse connectAndProcess(Serializer serializer, List&lt;ParameterValue&gt; parameters,
            BiFunction&lt;? super Integer, ? super String, Optional&lt;Class&lt;?&gt;&gt;&gt; responseCls, String url,
            Optional&lt;ParameterValue&gt; requestBody, Headers headers, final HttpMethod method)
            throws IOException, MalformedURLException, ProtocolException, StreamReadException, DatabindException {
<span class="fc" id="L304">        log.debug(&quot;Http.headers={}&quot;, headers);</span>
<span class="fc" id="L305">        HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();</span>
<span class="fc" id="L306">        con.setRequestMethod(method.name());</span>
<span class="fc" id="L307">        parameters.stream() //</span>
<span class="pc bpc" id="L308" title="3 of 4 branches missed.">                .filter(p -&gt; p.type() == ParameterType.HEADER &amp;&amp; p.value().isPresent()) //</span>
<span class="pc" id="L309">                .forEach(p -&gt; headers.put(p.name(), String.valueOf(p.value().get())));</span>
        // add request body content type (should just be one)
<span class="fc" id="L311">        parameters.stream().filter(p -&gt; p.contentType().isPresent())</span>
<span class="fc" id="L312">                .forEach(p -&gt; headers.put(&quot;Content-Type&quot;, p.contentType().get()));</span>
<span class="fc" id="L313">        headers.forEach((key, list) -&gt; {</span>
<span class="fc" id="L314">            con.setRequestProperty(key, list.stream().collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L315">        });</span>
<span class="fc" id="L316">        con.setDoInput(true);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (requestBody.isPresent()) {</span>
<span class="fc" id="L318">            con.setDoOutput(true);</span>
<span class="fc" id="L319">            Optional&lt;?&gt; body = requestBody.get().value();</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            if (body.isPresent()) {</span>
<span class="fc" id="L321">                try (OutputStream out = con.getOutputStream()) {</span>
<span class="fc" id="L322">                    serializer.serialize(body.get(), requestBody.get().contentType().get(), out);</span>
                }
            }
        }
<span class="fc" id="L326">        int statusCode = con.getResponseCode();</span>
<span class="fc" id="L327">        Headers responseHeaders = Headers.create(con.getHeaderFields());</span>
<span class="fc" id="L328">        String responseContentType = Optional.ofNullable(con.getHeaderField(&quot;Content-Type&quot;))</span>
<span class="fc" id="L329">                .orElse(&quot;application/octet-stream&quot;);</span>
        Object data;
<span class="fc" id="L331">        Optional&lt;Class&lt;?&gt;&gt; responseClass = responseCls.apply(statusCode, responseContentType);</span>
<span class="fc" id="L332">        try (InputStream in = log(con.getInputStream())) {</span>
<span class="fc" id="L333">            data = readResponse(serializer, responseClass, responseContentType, in);</span>
<span class="fc" id="L334">        } catch (IOException e) {</span>
<span class="fc" id="L335">            try (InputStream err = log(con.getErrorStream())) {</span>
<span class="fc" id="L336">                data = readResponse(serializer, responseClass, responseContentType, err);</span>
            }
<span class="fc" id="L338">        }</span>
<span class="fc" id="L339">        return new HttpResponse(statusCode, responseHeaders, Optional.of(data));</span>
    }

    private static InputStream log(InputStream inputStream) {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (!log.isDebugEnabled()) {</span>
<span class="fc" id="L344">            return inputStream;</span>
        }
<span class="nc" id="L346">        ByteArrayOutputStream bytes = new ByteArrayOutputStream();</span>
<span class="nc" id="L347">        return new InputStream() {</span>

            @Override
            public int read() throws IOException {
<span class="nc" id="L351">                int v = inputStream.read();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                if (v == -1) {</span>
<span class="nc" id="L353">                    log.debug(&quot;Http.inputStream=\n{}&quot;, new String(bytes.toByteArray(), StandardCharsets.UTF_8));</span>
                }
<span class="nc" id="L355">                bytes.write(v);</span>
<span class="nc" id="L356">                return v;</span>
            }

        };
    }

    @VisibleForTesting
    static String buildUrl(String basePath, String pathTemplate, List&lt;ParameterValue&gt; parameters) {
<span class="fc" id="L364">        Preconditions.checkArgument(pathTemplate.startsWith(&quot;/&quot;));</span>
        // substitute path parameters
<span class="fc" id="L366">        String path = stripFinalSlash(basePath) + insertParametersIntoPath(pathTemplate, parameters);</span>
        // build query string
<span class="fc" id="L368">        String queryString = parameters //</span>
<span class="fc" id="L369">                .stream() //</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                .filter(p -&gt; p.type() == ParameterType.QUERY) //</span>
<span class="fc" id="L371">                .filter(p -&gt; p.value().isPresent()) //</span>
<span class="fc" id="L372">                .map(p -&gt; urlEncode(p.name()) + &quot;=&quot; + p.value().map(x -&gt; valueToString(x)).orElse(&quot;&quot;)) //</span>
<span class="fc" id="L373">                .collect(Collectors.joining(&quot;&amp;&quot;));</span>
<span class="fc" id="L374">        return path + &quot;?&quot; + queryString;</span>
    }

    private static Object readResponse(Serializer serializer, Optional&lt;Class&lt;?&gt;&gt; responseType,
            String responseContentType, InputStream in) throws IOException, StreamReadException, DatabindException {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (responseType.isPresent()) {</span>
<span class="fc" id="L380">            return serializer.deserialize(responseType.get(), responseContentType, in);</span>
        } else {
<span class="nc" id="L382">            return new String(Util.read(in), StandardCharsets.UTF_8);</span>
        }
    }

    private static String valueToString(Object value) {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L388">            return &quot;&quot;;</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        } else if (value instanceof Collection) {</span>
<span class="nc" id="L390">            Collection&lt;?&gt; c = (Collection&lt;?&gt;) value;</span>
<span class="nc" id="L391">            return c.stream().map(x -&gt; valueToString(x)).collect(Collectors.joining(&quot;,&quot;));</span>
        } else {
<span class="fc" id="L393">            return urlEncode(value.toString());</span>
        }
    }

    private static String stripFinalSlash(String s) {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (s.endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L399">            return s.substring(0, s.length() - 2);</span>
        } else {
<span class="fc" id="L401">            return s;</span>
        }
    }

    private static String urlEncode(String s) {
        try {
<span class="fc" id="L407">            return URLEncoder.encode(s, &quot;UTF-8&quot;).replaceAll(&quot;\\+&quot;, &quot;%20&quot;);</span>
<span class="nc" id="L408">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L409">            throw new RuntimeException(e);</span>
        }
    }

    private static String insertParametersIntoPath(String pathTemplate, List&lt;ParameterValue&gt; parameters) {
<span class="fc" id="L414">        String s = pathTemplate;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (ParameterValue p : parameters) {</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (p.type() == ParameterType.PATH) {</span>
<span class="fc" id="L417">                s = insertParameter(s, p.name(), p.value().get());</span>
            }
<span class="fc" id="L419">        }</span>
<span class="fc" id="L420">        return s;</span>
    }

    private static String insertParameter(String s, String name, Object object) {
<span class="fc" id="L424">        return s.replace(&quot;{&quot; + name + &quot;}&quot;, urlEncode(object.toString()));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>