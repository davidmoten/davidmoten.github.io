<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SchemasCodeWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">openapi-codegen-generator</a> &gt; <a href="index.source.html" class="el_package">org.davidmoten.oa3.codegen.generator.writer</a> &gt; <span class="el_source">SchemasCodeWriter.java</span></div><h1>SchemasCodeWriter.java</h1><pre class="source lang-java linenums">package org.davidmoten.oa3.codegen.generator.writer;

import static org.davidmoten.oa3.codegen.generator.internal.Util.toPrimitive;
import static org.davidmoten.oa3.codegen.generator.internal.WriterUtil.IMPORTS_HERE;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.davidmoten.oa3.codegen.generator.Generator.ClassType;
import org.davidmoten.oa3.codegen.generator.Generator.Cls;
import org.davidmoten.oa3.codegen.generator.Generator.Discriminator;
import org.davidmoten.oa3.codegen.generator.Generator.Field;
import org.davidmoten.oa3.codegen.generator.Names;
import org.davidmoten.oa3.codegen.generator.SchemaCategory;
import org.davidmoten.oa3.codegen.generator.ServerGeneratorType;
import org.davidmoten.oa3.codegen.generator.internal.CodePrintWriter;
import org.davidmoten.oa3.codegen.generator.internal.Imports;
import org.davidmoten.oa3.codegen.generator.internal.Indent;
import org.davidmoten.oa3.codegen.generator.internal.Javadoc;
import org.davidmoten.oa3.codegen.generator.internal.Mutable;
import org.davidmoten.oa3.codegen.generator.internal.WriterUtil;
import org.davidmoten.oa3.codegen.http.HasEncoding;
import org.davidmoten.oa3.codegen.http.HasStringValue;
import org.davidmoten.oa3.codegen.runtime.AnyOfDeserializer;
import org.davidmoten.oa3.codegen.runtime.AnyOfMember;
import org.davidmoten.oa3.codegen.runtime.AnyOfSerializer;
import org.davidmoten.oa3.codegen.runtime.Config;
import org.davidmoten.oa3.codegen.runtime.DiscriminatorHelper;
import org.davidmoten.oa3.codegen.runtime.JsonNullableOctetsDeserializer;
import org.davidmoten.oa3.codegen.runtime.JsonNullableOctetsSerializer;
import org.davidmoten.oa3.codegen.runtime.NullEnumDeserializer;
import org.davidmoten.oa3.codegen.runtime.OctetsDeserializer;
import org.davidmoten.oa3.codegen.runtime.OctetsSerializer;
import org.davidmoten.oa3.codegen.runtime.OptionalOctetsDeserializer;
import org.davidmoten.oa3.codegen.runtime.OptionalOctetsSerializer;
import org.davidmoten.oa3.codegen.runtime.PolymorphicDeserializer;
import org.davidmoten.oa3.codegen.runtime.PolymorphicType;
import org.davidmoten.oa3.codegen.runtime.Preconditions;
import org.davidmoten.oa3.codegen.runtime.RuntimeUtil;
import org.davidmoten.oa3.codegen.util.Util;
import org.openapitools.jackson.nullable.JsonNullable;
import org.springframework.boot.context.properties.ConstructorBinding;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;
import com.fasterxml.jackson.annotation.JsonUnwrapped;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.github.davidmoten.guavamini.Maps;

public final class SchemasCodeWriter {

    private SchemasCodeWriter() {
        // prevent instantiation
    }

    public static void writeSchemaClass(Names names, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces, Cls cls,
            String schemaName) {
<span class="pc bpc" id="L85" title="1 of 6 branches missed.">        if ((cls.category == SchemaCategory.PATH || cls.category == SchemaCategory.RESPONSE) &amp;&amp; cls.schema.isPresent()</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">                &amp;&amp; cls.schema.get().get$ref() != null) {</span>
            // when a cls has a ref and is used with a Path or Response then the ref class
            // is used in generated code
<span class="fc" id="L89">            return;</span>
        }
<span class="fc" id="L91">        CodePrintWriter out = CodePrintWriter.create(cls.fullClassName, names.simpleNameInPackage(cls.fullClassName));</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (cls.fullClassName.equals(&quot;test.schema.StoredValueBalanceMergeRequest&quot;)) {</span>
<span class="nc" id="L93">            System.out.println(&quot;here&quot;);</span>
        }
<span class="fc" id="L95">        SchemasCodeWriter.writeClass(out, cls, fullClassNameInterfaces, names);</span>
<span class="fc" id="L96">        WriterUtil.writeContent(names, out);</span>
<span class="fc" id="L97">    }</span>

    public static void writeGlobalsClass(Names names) {
<span class="fc" id="L100">        String fullClassName = names.globalsFullClassName();</span>
<span class="fc" id="L101">        CodePrintWriter out = CodePrintWriter.create(fullClassName, names.simpleNameInPackage(fullClassName));</span>
<span class="fc" id="L102">        out.line(&quot;package %s;&quot;, Names.pkg(fullClassName));</span>
<span class="fc" id="L103">        out.println();</span>
<span class="fc" id="L104">        out.format(&quot;%s&quot;, IMPORTS_HERE);</span>
<span class="fc" id="L105">        WriterUtil.addGeneratedAnnotation(out);</span>
<span class="fc" id="L106">        out.line(&quot;public final class %s {&quot;, Names.simpleClassName(fullClassName));</span>
<span class="fc" id="L107">        out.println();</span>
<span class="fc" id="L108">        out.line(&quot;private static volatile %s config = %s.builder().build();&quot;, Config.class, Config.class);</span>
<span class="fc" id="L109">        out.println();</span>
<span class="fc" id="L110">        out.line(&quot;public static void setConfig(%s configuration) {&quot;, Config.class);</span>
<span class="fc" id="L111">        out.line(&quot;config = configuration;&quot;);</span>
<span class="fc" id="L112">        out.closeParen();</span>
<span class="fc" id="L113">        out.println();</span>
<span class="fc" id="L114">        out.line(&quot;public static %s config() {&quot;, Config.class);</span>
<span class="fc" id="L115">        out.line(&quot;return config;&quot;);</span>
<span class="fc" id="L116">        out.closeParen();</span>
<span class="fc" id="L117">        out.closeParen();</span>
<span class="fc" id="L118">        WriterUtil.writeContent(names, out);</span>
<span class="fc" id="L119">    }</span>

    private static void writeClass(CodePrintWriter out, Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces,
            Names names) {
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (cls.topLevel) {</span>
<span class="fc" id="L124">            out.line(&quot;package %s;&quot;, cls.pkg());</span>
<span class="fc" id="L125">            out.println();</span>
<span class="fc" id="L126">            out.format(&quot;%s&quot;, IMPORTS_HERE);</span>
        } 
        // reserve class names in Imports for member classes
<span class="fc" id="L129">        reserveMemberClassNamesInImports(out.imports(), cls);</span>
<span class="fc" id="L130">        writeClassDeclaration(out, cls, fullClassNameInterfaces);</span>
<span class="fc" id="L131">        writeEnumMembers(out, cls);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (isPolymorphic(cls)) {</span>
<span class="fc" id="L133">            writePolymorphicClassContent(out, cls, names);</span>
        } else {
<span class="fc" id="L135">            writeFields(out, cls);</span>
<span class="fc" id="L136">            writeConstructor(out, cls, fullClassNameInterfaces, names);</span>
<span class="fc" id="L137">            writeGetters(out, cls, fullClassNameInterfaces);</span>
<span class="fc" id="L138">            writePropertiesMapGetter(out, cls);</span>
<span class="fc" id="L139">            writeMutators(out, cls, fullClassNameInterfaces);</span>
<span class="fc" id="L140">            writeBuilder(out, cls, fullClassNameInterfaces);</span>
        }
<span class="fc" id="L142">        writeEnumCreator(out, cls);</span>
<span class="fc" id="L143">        writeEnumDeserializer(out, cls);</span>
<span class="fc" id="L144">        writeMemberClasses(out, cls, fullClassNameInterfaces, names);</span>
<span class="fc bfc" id="L145" title="All 4 branches covered.">        if (cls.classType != ClassType.ENUM &amp;&amp; cls.classType != ClassType.ONE_OR_ANY_OF_DISCRIMINATED) {</span>
<span class="fc" id="L146">            writeEqualsMethod(out, cls);</span>
<span class="fc" id="L147">            writeHashCodeMethod(out, cls);</span>
<span class="fc" id="L148">            writeToStringMethod(out, cls);</span>
        }
<span class="fc" id="L150">        out.closeParen();</span>
<span class="fc" id="L151">    }</span>

    private static void reserveMemberClassNamesInImports(Imports imports, Cls cls) {
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (cls.classes.isEmpty()) {</span>
<span class="fc" id="L155">            return;</span>
        }
<span class="fc" id="L157">        cls.classes.forEach(c -&gt; reserveMemberClassNamesInImports(imports, c));</span>
<span class="fc" id="L158">        cls.classes.forEach(c -&gt; imports.add(c.fullClassName));</span>
<span class="fc" id="L159">    }</span>

    private static boolean isPolymorphic(Cls cls) {
<span class="fc bfc" id="L162" title="All 8 branches covered.">        return cls.classType == ClassType.ONE_OF_NON_DISCRIMINATED //</span>
                || cls.classType == ClassType.ANY_OF_NON_DISCRIMINATED //
                || cls.classType == ClassType.ONE_OR_ANY_OF_DISCRIMINATED //
                || cls.classType == ClassType.ALL_OF;
    }

    private static void addOverrideAnnotation(CodePrintWriter out) {
<span class="fc" id="L169">        out.println();</span>
<span class="fc" id="L170">        out.line(&quot;@%s&quot;, Override.class);</span>
<span class="fc" id="L171">    }</span>

    private static void writeEnumCreator(CodePrintWriter out, Cls cls) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (cls.classType == ClassType.ENUM) {</span>
<span class="fc" id="L175">            String simpleClassName = Names.simpleClassName(cls.fullClassName);</span>
<span class="fc" id="L176">            out.println();</span>
<span class="fc" id="L177">            out.line(&quot;@%s&quot;, JsonCreator.class);</span>
<span class="fc" id="L178">            out.line(&quot;public static %s fromValue(%s value) {&quot;, simpleClassName, Object.class);</span>
<span class="fc" id="L179">            out.line(&quot;for (%s x: %s.values()) {&quot;, simpleClassName, simpleClassName);</span>
            // be careful because x.value can be primitive
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if (cls.isNullableEnum()) {</span>
<span class="fc" id="L182">                out.line(&quot;if (%s.equals(value, x.value.get())) {&quot;, Objects.class);</span>
            } else {
<span class="fc" id="L184">                out.line(&quot;if (%s.equals(value, x.value)) {&quot;, Objects.class);</span>
            }
<span class="fc" id="L186">            out.line(&quot;return x;&quot;);</span>
<span class="fc" id="L187">            out.closeParen();</span>
<span class="fc" id="L188">            out.closeParen();</span>
<span class="fc" id="L189">            out.line(&quot;throw new %s(\&quot;unexpected enum value: '\&quot; + value + \&quot;'\&quot;);&quot;, IllegalArgumentException.class);</span>
<span class="fc" id="L190">            out.closeParen();</span>
        }
<span class="fc" id="L192">    }</span>

    private static void writeEnumDeserializer(CodePrintWriter out, Cls cls) {
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (cls.hasEnumNullValue()) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            String nullValueMemberName = cls.enumMembers.stream().filter(x -&gt; x.parameter == null).map(x -&gt; x.name)</span>
<span class="fc" id="L197">                    .findFirst().get();</span>
<span class="fc" id="L198">            out.println();</span>
<span class="fc" id="L199">            out.line(&quot;public static class _Deserializer extends %s&lt;%s&gt; {&quot;, NullEnumDeserializer.class, cls.simpleName());</span>
<span class="fc" id="L200">            out.line(&quot;protected _Deserializer() {&quot;);</span>
<span class="fc" id="L201">            out.line(&quot;super(%s.class, %s.class, %s);&quot;, cls.simpleName(), out.add(cls.enumValueFullType),</span>
                    nullValueMemberName);
<span class="fc" id="L203">            out.closeParen();</span>
<span class="fc" id="L204">            out.closeParen();</span>
        }
<span class="fc" id="L206">    }</span>

    private static void writeClassDeclaration(CodePrintWriter out, Cls cls,
            Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces) {
<span class="fc" id="L210">        String modifier = classModifier(cls);</span>
<span class="fc" id="L211">        Set&lt;Cls&gt; interfaces = fullClassNameInterfaces.get(cls.fullClassName);</span>
<span class="fc" id="L212">        String implementsClause = implementsClause(out.imports(), interfaces, cls);</span>
        //TODO ensure contentType() and value() methods of HasEncoding are annotated with @Override
        
        final boolean javadocExists;
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (cls.description.isPresent()) {</span>
<span class="fc" id="L217">            String html = WriterUtil.markdownToHtml(cls.description.get());</span>
<span class="fc" id="L218">            javadocExists = Javadoc.printJavadoc(out, out.indent(), html, true);</span>
<span class="fc" id="L219">        } else {</span>
<span class="fc" id="L220">            javadocExists = false;</span>
        }
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (!javadocExists) {</span>
<span class="fc" id="L223">            out.println();</span>
        }
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (cls.classType == ClassType.ONE_OR_ANY_OF_DISCRIMINATED) {</span>
<span class="fc" id="L226">            writeJsonTypeInfoAnnotation(out, cls);</span>
<span class="fc bfc" id="L227" title="All 4 branches covered.">        } else if (cls.classType == ClassType.ONE_OF_NON_DISCRIMINATED || cls.classType == ClassType.ALL_OF) {</span>
<span class="fc" id="L228">            writePolymorphicDeserializerAnnotation(out, cls);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        } else if (cls.classType == ClassType.ANY_OF_NON_DISCRIMINATED) {</span>
<span class="fc" id="L230">            writeAnyOfSerializerAnnotations(out, cls);</span>
        }
<span class="fc bfc" id="L232" title="All 6 branches covered.">        if (cls.classType != ClassType.ENUM &amp;&amp; cls.classType != ClassType.ONE_OR_ANY_OF_DISCRIMINATED</span>
                &amp;&amp; cls.classType != ClassType.ANY_OF_NON_DISCRIMINATED) {
<span class="fc" id="L234">            writeJsonIncludeAnnotation(out);</span>
<span class="fc" id="L235">            writeAutoDetectAnnotation(out);</span>
        }
<span class="fc bfc" id="L237" title="All 4 branches covered.">        if (cls.classType == ClassType.ENUM &amp;&amp; cls.hasEnumNullValue()) {</span>
<span class="fc" id="L238">            writeEnumNullValueDeserializerAnnotation(out, cls);</span>
        }
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (cls.topLevel) {</span>
<span class="fc" id="L241">            WriterUtil.addGeneratedAnnotation(out);</span>
        }
<span class="fc" id="L243">        out.line(&quot;public %s%s %s%s {&quot;, modifier, cls.classType.word(), cls.simpleName(), implementsClause);</span>
<span class="fc" id="L244">    }</span>

    private static void writeAnyOfSerializerAnnotations(CodePrintWriter out, Cls cls) {
<span class="fc" id="L247">        out.line(&quot;@%s(using = %s._Deserializer.class)&quot;, JsonDeserialize.class, cls.simpleName());</span>
<span class="fc" id="L248">        out.line(&quot;@%s(using = %s._Serializer.class)&quot;, JsonSerialize.class, cls.simpleName());</span>
<span class="fc" id="L249">    }</span>

    private static void writeEnumNullValueDeserializerAnnotation(CodePrintWriter out, Cls cls) {
<span class="fc" id="L252">        out.line(&quot;@%s(using = %s._Deserializer.class)&quot;, JsonDeserialize.class, cls.simpleName());</span>
<span class="fc" id="L253">    }</span>

    private static void writeJsonIncludeAnnotation(CodePrintWriter out) {
<span class="fc" id="L256">        out.line(&quot;@%s(%s.NON_ABSENT)&quot;, JsonInclude.class, Include.class);</span>
<span class="fc" id="L257">    }</span>

    private static String classModifier(Cls cls) {
        final String modifier;
<span class="fc bfc" id="L261" title="All 4 branches covered.">        if (cls.classType == ClassType.ONE_OR_ANY_OF_DISCRIMINATED || cls.classType == ClassType.ENUM) {</span>
<span class="fc" id="L262">            modifier = &quot;&quot;;</span>
        } else {
<span class="fc bfc" id="L264" title="All 2 branches covered.">            modifier = cls.topLevel ? &quot;final &quot; : &quot;static final &quot;;</span>
        }
<span class="fc" id="L266">        return modifier;</span>
    }

    private static String implementsClause(Imports imports, Set&lt;Cls&gt; interfaces, Cls cls) {
<span class="fc" id="L270">        interfaces = Util.orElse(interfaces, Collections.emptySet());</span>
        final String implemented;
<span class="fc bfc" id="L272" title="All 4 branches covered.">        if (interfaces.isEmpty() &amp;&amp; !cls.hasEncoding()) {</span>
<span class="fc" id="L273">            implemented = &quot;&quot;;</span>
        } else {
<span class="fc" id="L275">            Stream&lt;String&gt; a = interfaces //</span>
<span class="fc" id="L276">                    .stream() //</span>
<span class="fc" id="L277">                    .map(x -&gt; x.fullClassName);</span>
<span class="fc" id="L278">            Stream&lt;String&gt; b = Stream.of(HasEncoding.class.getCanonicalName()) //</span>
<span class="fc bfc" id="L279" title="All 4 branches covered.">                    .filter(x -&gt; cls.hasEncoding() &amp;&amp; cls.classType != ClassType.ENUM);</span>
            // for use with ContentType class
<span class="fc" id="L281">            Stream&lt;String&gt; c = Stream.of(HasStringValue.class.getCanonicalName()) //</span>
<span class="fc bfc" id="L282" title="All 4 branches covered.">                    .filter(x -&gt; cls.hasEncoding() &amp;&amp; cls.classType == ClassType.ENUM);</span>
<span class="fc" id="L283">            implemented = &quot; implements &quot; + Stream.concat(a, Stream.concat(b, c)) //</span>
<span class="fc" id="L284">                    .map(x -&gt; imports.add(x)) //</span>
<span class="fc" id="L285">                    .collect(Collectors.joining(&quot;, &quot;));</span>
        }
<span class="fc" id="L287">        return implemented;</span>
    }

    private static void writeJsonTypeInfoAnnotation(CodePrintWriter out, Cls cls) {
<span class="fc" id="L291">        out.line(&quot;@%s(use = %s.NAME, property = \&quot;%s\&quot;, include = %s.EXISTING_PROPERTY, visible = true)&quot;,</span>
                JsonTypeInfo.class, Id.class, cls.discriminator.propertyName, As.class);
<span class="fc" id="L293">        out.right().right();</span>
<span class="fc" id="L294">        String types = cls.fields.stream().map(x -&gt; {</span>
            final String fieldImportedType;
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (x.fullClassName.startsWith(cls.fullClassName)) {</span>
<span class="fc" id="L297">                fieldImportedType = Names.simpleClassName(cls.fullClassName)</span>
<span class="fc" id="L298">                        + x.fullClassName.substring(cls.fullClassName.length());</span>
            } else {
<span class="fc" id="L300">                fieldImportedType = out.add(x.fullClassName);</span>
            }
<span class="fc" id="L302">            return String.format(&quot;\n%s@%s.Type(value = %s.class, name = \&quot;%s\&quot;)&quot;, out.indent(), out.add(JsonSubTypes.class),</span>
<span class="fc" id="L303">                    fieldImportedType, cls.discriminator.discriminatorValueFromFullClassName(x.fullClassName));</span>
<span class="fc" id="L304">        }).collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L305">        out.left().left();</span>
<span class="fc" id="L306">        out.line(&quot;@%s({%s})&quot;, JsonSubTypes.class, types);</span>
<span class="fc" id="L307">    }</span>

    private static void writePolymorphicDeserializerAnnotation(CodePrintWriter out, Cls cls) {
<span class="fc" id="L310">        out.line(&quot;@%s(using = %s._Deserializer.class)&quot;, JsonDeserialize.class, cls.simpleName());</span>
<span class="fc" id="L311">    }</span>

    private static void writeAutoDetectAnnotation(CodePrintWriter out) {
<span class="fc" id="L314">        out.line(&quot;@%s(&quot;, JsonAutoDetect.class);</span>
<span class="fc" id="L315">        out.right().right();</span>
<span class="fc" id="L316">        out.line(&quot;fieldVisibility = %s.Visibility.ANY,&quot;, JsonAutoDetect.class);</span>
<span class="fc" id="L317">        out.line(&quot;creatorVisibility = %s.Visibility.ANY,&quot;, JsonAutoDetect.class);</span>
<span class="fc" id="L318">        out.line(&quot;setterVisibility = %s.Visibility.ANY)&quot;, JsonAutoDetect.class);</span>
<span class="fc" id="L319">        out.left().left();</span>
<span class="fc" id="L320">    }</span>
    
<span class="fc" id="L322">    private final static ObjectMapper MAPPER = new ObjectMapper();</span>
    
    private static String escapedJson(ObjectNode node) {
        try {
<span class="fc" id="L326">            return MAPPER.writeValueAsString(node).replace(&quot;\n&quot;, &quot;\\n&quot;).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);</span>
<span class="nc" id="L327">        } catch (JsonProcessingException e) {</span>
<span class="nc" id="L328">            throw new RuntimeException(e);</span>
        }
    }

    private static void writeEnumMembers(CodePrintWriter out, Cls cls) {
        final String parameterFullClassName;
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (!cls.fields.isEmpty()) {</span>
<span class="fc" id="L335">            parameterFullClassName = cls.fields.get(0).fullClassName;</span>
        } else {
<span class="nc" id="L337">            parameterFullClassName = &quot;NotUsed&quot;;</span>
        }
<span class="fc" id="L339">        int[] index = new int[] {-1};</span>
<span class="fc" id="L340">        String text = cls.enumMembers.stream() //</span>
<span class="fc" id="L341">                .map(x -&gt; {</span>
<span class="fc" id="L342">                    index[0]++;</span>
                    final String memberName;
<span class="fc bfc" id="L344" title="All 2 branches covered.">                    if (!cls.enumNames.isEmpty()) {</span>
<span class="fc" id="L345">                        memberName = cls.enumNames.get(index[0]);</span>
                    } else {
<span class="fc" id="L347">                        memberName = x.name;</span>
                    }
<span class="fc bfc" id="L349" title="All 2 branches covered.">                    if (x.parameter instanceof ObjectNode) {</span>
<span class="fc" id="L350">                        return String.format(&quot;%s%s(%s.toMap(\&quot;%s\&quot;))&quot;, out.indent(), memberName, out.add(RuntimeUtil.class),</span>
<span class="fc" id="L351">                                escapedJson((ObjectNode) x.parameter));</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    } else if (parameterFullClassName.equals(BigInteger.class.getCanonicalName())</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                            || parameterFullClassName.equals(BigDecimal.class.getCanonicalName())) {</span>
<span class="fc" id="L354">                        return String.format(&quot;%s%s(new %s(\&quot;\&quot;))&quot;, out.indent(), memberName,</span>
<span class="fc" id="L355">                                out.add(parameterFullClassName), x.parameter);</span>
                    } else {
                        String delim = x.parameter instanceof String //
<span class="fc bfc" id="L358" title="All 2 branches covered.">                                || //</span>
<span class="pc bpc" id="L359" title="1 of 4 branches missed.">                                cls.enumValueFullType.equals(String.class.getCanonicalName()) // </span>
<span class="fc" id="L360">                                &amp;&amp; x.parameter instanceof Boolean ? &quot;\&quot;&quot; : &quot;&quot;;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                        if (x.nullable) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">                            if (x.parameter == null) {</span>
<span class="fc" id="L363">                                return String.format(&quot;%s%s(%s.empty())&quot;, out.indent(), memberName,</span>
<span class="fc" id="L364">                                        out.add(Optional.class), delim, x.parameter, delim);</span>
                            } else {
<span class="fc" id="L366">                                return String.format(&quot;%s%s(%s.of(%s%s%s))&quot;, out.indent(), memberName,</span>
<span class="fc" id="L367">                                        out.add(Optional.class), delim, x.parameter, delim);</span>
                            }
                        } else {
<span class="fc" id="L370">                            return String.format(&quot;%s%s(%s%s%s)&quot;, out.indent(), memberName, delim, x.parameter, delim);</span>
                        }
                    }
<span class="fc" id="L373">                }).collect(Collectors.joining(&quot;,\n&quot;));</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (!text.isEmpty()) {</span>
<span class="fc" id="L375">            out.println(&quot;\n&quot; + text + &quot;;&quot;);</span>
        }
<span class="fc" id="L377">    }</span>

    private static void writePolymorphicClassContent(CodePrintWriter out, Cls cls, Names names) {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (cls.classType == ClassType.ONE_OR_ANY_OF_DISCRIMINATED) {</span>
<span class="fc" id="L381">            out.println();</span>
<span class="fc" id="L382">            out.line(&quot;%s %s();&quot;, String.class, cls.discriminator.fieldName);</span>
        } else {
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (cls.classType == ClassType.ONE_OF_NON_DISCRIMINATED) {</span>
<span class="fc" id="L385">                out.println();</span>
<span class="fc" id="L386">                writeJsonValueAnnotation(out);</span>
<span class="fc" id="L387">                out.line(&quot;private final %s %s;&quot;, Object.class, &quot;value&quot;);</span>

                // add constructor for each member of the oneOf (fieldTypes)
                // as there are multiple constructors we cannot add ConstructorBinding
                // annotations so polymorphic stuff can't be used to bind to rest method
                // parameters
<span class="fc" id="L393">                writeOneOfAnyOfNonDiscriminatedObjectConstructor(out, cls);</span>
<span class="fc" id="L394">                cls.fields.forEach(f -&gt; writeOneOfAnyOfNonDiscriminatedMemberSpecificConstructor(out, cls, f));</span>
<span class="fc" id="L395">                out.println();</span>
<span class="fc" id="L396">                writeGetter(out, out.add(Object.class), &quot;value&quot;, &quot;value&quot;);</span>
<span class="fc" id="L397">                writeNonDiscriminatedBuilder(out, cls);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            } else if (cls.classType == ClassType.ANY_OF_NON_DISCRIMINATED) {</span>
<span class="fc" id="L399">                writeFields(out, cls);</span>
                
                // write constructor
<span class="fc" id="L402">                out.right().right();</span>
<span class="fc" id="L403">                final String parameters = cls.fields //</span>
<span class="fc" id="L404">                        .stream() ///</span>
<span class="fc" id="L405">                        .map(x -&gt; String.format(&quot;\n%s%s %s&quot;, out.indent(),</span>
<span class="fc" id="L406">                                x.resolvedType(out.imports()), x.fieldName(cls)))</span>
<span class="fc" id="L407">                        .collect(Collectors.joining(&quot;,&quot;));</span>
<span class="fc" id="L408">                out.left().left();</span>
<span class="fc" id="L409">                out.println();</span>
<span class="fc" id="L410">                out.line(&quot;private %s(%s) {&quot;, Names.simpleClassName(cls.fullClassName), parameters);</span>
<span class="fc" id="L411">                ifValidate(cls, out, names, //</span>
<span class="fc" id="L412">                        o -&gt; cls.fields.stream().forEach(x -&gt; {</span>
<span class="fc" id="L413">                                checkNotNull(cls, o, x);</span>
<span class="fc" id="L414">                        }));</span>
<span class="fc" id="L415">                cls.fields.stream().forEach(x -&gt; {</span>
<span class="fc" id="L416">                    assignField(out, cls, x);</span>
<span class="fc" id="L417">                });</span>
<span class="fc" id="L418">                out.closeParen();</span>
<span class="fc" id="L419">                out.println();</span>
<span class="fc" id="L420">                out.line(&quot;public static %s of(%s) {&quot;, cls.simpleName(), parameters);</span>
<span class="fc" id="L421">                String fields = cls.fields.stream().map(x -&gt; x.fieldName).collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L422">                out.line(&quot;%s $o = new %s(%s);&quot;, cls.simpleName(), cls.simpleName(), fields);</span>
<span class="fc" id="L423">                out.line(&quot;%s.checkCanSerialize(%s.config(), $o);&quot;, //</span>
                        RuntimeUtil.class, //
<span class="fc" id="L425">                        out.add(names.globalsFullClassName()));</span>
<span class="fc" id="L426">                out.line(&quot;return $o;&quot;);</span>
<span class="fc" id="L427">                out.closeParen();</span>
                
                // write getters
<span class="fc" id="L430">                cls.fields.forEach(f -&gt; {</span>
<span class="fc" id="L431">                    out.println();</span>
<span class="fc" id="L432">                    writeGetter(out, f.resolvedType(out.imports()), f.fieldName(cls),</span>
<span class="fc" id="L433">                            f.fieldName(cls));</span>
<span class="fc" id="L434">                });</span>
                
<span class="fc" id="L436">                writeAnyOfOrAllOfBuilder(out, cls, true);</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">            } else if (cls.classType == ClassType.ALL_OF) {</span>
                // allof
<span class="fc" id="L439">                writeFields(out, cls);</span>

<span class="fc" id="L441">                out.right().right();</span>
<span class="fc" id="L442">                final String parameters = cls //</span>
                        .fields //
<span class="fc" id="L444">                        .stream() //</span>
<span class="fc" id="L445">                        .map(x -&gt; String.format(&quot;\n%s%s %s&quot;, out.indent(), x.resolvedType(out.imports()),</span>
<span class="fc" id="L446">                                x.fieldName(cls))) //</span>
<span class="fc" id="L447">                        .collect(Collectors.joining(&quot;,&quot;));</span>
<span class="fc" id="L448">                out.left().left();</span>
<span class="fc" id="L449">                out.println();</span>
<span class="fc" id="L450">                out.line(&quot;public %s(%s) {&quot;, Names.simpleClassName(cls.fullClassName), parameters);</span>
<span class="fc" id="L451">                ifValidate(cls, out, names, //</span>
<span class="fc" id="L452">                        o -&gt; cls.fields.stream().forEach(x -&gt; {</span>
<span class="pc bpc" id="L453" title="2 of 4 branches missed.">                            if (!x.isPrimitive() &amp;&amp; x.required) {</span>
<span class="fc" id="L454">                                checkNotNull(cls, o, x);</span>
                            } else {
<span class="nc" id="L456">                                o.line(&quot;// TODO %s&quot;, x.fieldName);</span>
                            }
<span class="fc" id="L458">                            validateMore(o, cls, x);</span>
<span class="fc" id="L459">                        }));</span>
<span class="fc" id="L460">                cls.fields.stream().forEach(x -&gt; {</span>
<span class="fc" id="L461">                    assignField(out, cls, x);</span>
<span class="fc" id="L462">                });</span>
<span class="fc" id="L463">                out.closeParen();</span>

                // write getters for allOf members
<span class="fc" id="L466">                cls.fields.forEach(f -&gt; {</span>
<span class="fc" id="L467">                    out.println();</span>
<span class="fc" id="L468">                    writeGetter(out, f.resolvedType(out.imports()),</span>
<span class="fc" id="L469">                            &quot;as&quot; + Names.simpleClassName(f.resolvedType(out.imports())),</span>
<span class="fc" id="L470">                            f.fieldName(cls));</span>
<span class="fc" id="L471">                });</span>
                
                // write all field getters
<span class="fc" id="L474">                Set&lt;String&gt; used = new HashSet&lt;&gt;();</span>
<span class="fc" id="L475">                cls.fields.forEach(field -&gt; {</span>
<span class="fc" id="L476">                    Optional&lt;Cls&gt; c = names.cls(field.fullClassName);</span>
<span class="pc bpc" id="L477" title="1 of 4 branches missed.">                    if (c.isPresent() &amp;&amp; c.get().classType != ClassType.ONE_OF_NON_DISCRIMINATED) {</span>
<span class="fc" id="L478">                        c.get().fields //</span>
<span class="fc" id="L479">                        .stream() //</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                        .filter(f -&gt; !f.mapType.isPresent()) //</span>
<span class="fc" id="L481">                        .forEach(f -&gt; {</span>
<span class="fc" id="L482">                            String fieldName = f.fieldName(c.get());</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">                            if (!used.contains(fieldName)) {</span>
<span class="fc" id="L484">                                used.add(fieldName);</span>
<span class="fc" id="L485">                                String type = f.resolvedTypePublicConstructor(out.imports());</span>
<span class="fc" id="L486">                                out.println();</span>
<span class="fc" id="L487">                                out.line(&quot;public %s %s() {&quot;, type, fieldName);</span>
                                final String getter;
<span class="fc bfc" id="L489" title="All 2 branches covered.">                                if (c.get().classType == ClassType.ALL_OF) {</span>
<span class="fc" id="L490">                                    getter = &quot;as&quot; + Names.upperFirst(fieldName);</span>
                                } else {
<span class="fc" id="L492">                                    getter = fieldName;</span>
                                }
<span class="fc" id="L494">                                out.line(&quot;return %s.%s();&quot;, field.fieldName(cls), getter);</span>
<span class="fc" id="L495">                                out.closeParen();</span>
                            }
<span class="fc" id="L497">                        });</span>
                    }
<span class="fc" id="L499">                });</span>
                // write allof builder
<span class="fc" id="L501">                writeAnyOfOrAllOfBuilder(out, cls, false);</span>
            }

<span class="fc" id="L504">            out.println();</span>
<span class="fc" id="L505">            out.line(&quot;@%s(\&quot;serial\&quot;)&quot;, SuppressWarnings.class);</span>
            final Class&lt;?&gt; polymorphicDeserializer;
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (cls.classType == ClassType.ANY_OF_NON_DISCRIMINATED) {</span>
<span class="fc" id="L508">                polymorphicDeserializer = AnyOfDeserializer.class;</span>
            } else {
<span class="fc" id="L510">                polymorphicDeserializer = PolymorphicDeserializer.class;</span>
            }
<span class="fc" id="L512">            out.line(&quot;public static final class _Deserializer extends %s&lt;%s&gt; {&quot;, polymorphicDeserializer,</span>
<span class="fc" id="L513">                    cls.simpleName());</span>
<span class="fc" id="L514">            out.println();</span>
<span class="fc" id="L515">            out.line(&quot;public _Deserializer() {&quot;);</span>
<span class="fc" id="L516">            String classes = cls.fields //</span>
<span class="fc" id="L517">                    .stream() //</span>
<span class="fc" id="L518">                    .map(x -&gt; out.add(toPrimitive(x.fullClassName)) + &quot;.class&quot;) //</span>
<span class="fc" id="L519">                    .collect(Collectors.joining(&quot;, &quot;));</span>
            
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (cls.classType == ClassType.ANY_OF_NON_DISCRIMINATED) {</span>
                // members is used with anyOf only
<span class="fc" id="L523">                String members = cls.fields //</span>
<span class="fc" id="L524">                        .stream() //</span>
<span class="fc" id="L525">                        .map(x -&gt; {</span>
<span class="fc" id="L526">                            String c = out.add(x.fullClassName) + &quot;.class&quot;;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                            String method = x.nullable ? &quot;nullable&quot; : &quot;nonNullable&quot;;</span>
<span class="fc" id="L528">                            return String.format(&quot;%s.%s(%s)&quot;, out.add(AnyOfMember.class), method, c);</span>
                        }) //
<span class="fc" id="L530">                        .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L531">                out.line(&quot;super(%s.config(), %s.class, %s);&quot;, out.add(names.globalsFullClassName()), cls.simpleName(),</span>
                        members);
<span class="fc" id="L533">            } else {</span>
<span class="fc" id="L534">                out.line(&quot;super(%s.config(), %s.%s, %s.class, %s);&quot;, out.add(names.globalsFullClassName()),</span>
<span class="fc" id="L535">                        PolymorphicType.class, cls.polymorphicType.name(), cls.simpleName(), classes);</span>
            }
<span class="fc" id="L537">            out.closeParen();</span>
<span class="fc" id="L538">            out.closeParen();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">            if (cls.classType == ClassType.ANY_OF_NON_DISCRIMINATED) {</span>
<span class="fc" id="L540">                out.println();</span>
<span class="fc" id="L541">                out.line(&quot;@%s(\&quot;serial\&quot;)&quot;, SuppressWarnings.class);</span>
<span class="fc" id="L542">                out.line(&quot;public static final class _Serializer extends %s&lt;%s&gt; {&quot;, AnyOfSerializer.class,</span>
<span class="fc" id="L543">                        cls.simpleName());</span>
<span class="fc" id="L544">                out.println();</span>
<span class="fc" id="L545">                out.line(&quot;public _Serializer() {&quot;);</span>
<span class="fc" id="L546">                out.line(&quot;super(%s.config(), %s.class);&quot;, out.add(names.globalsFullClassName()), cls.simpleName());</span>
<span class="fc" id="L547">                out.closeParen();</span>
<span class="fc" id="L548">                out.closeParen();</span>
            }
        }
<span class="fc" id="L551">    }</span>

    private static void writeAnyOfOrAllOfBuilder(CodePrintWriter out, Cls cls, boolean useOf) {
<span class="fc" id="L554">        List&lt;BuilderWriter.Field&gt; fields = //</span>
<span class="fc" id="L555">                cls.fields.stream() //</span>
<span class="fc" id="L556">                        .map(f -&gt; new BuilderWriter.Field(f.fieldName(cls), f.fullClassName, f.required, f.isArray,</span>
<span class="fc" id="L557">                                f.mapType, f.nullable, Optional.empty())) //</span>
<span class="fc" id="L558">                        .collect(Collectors.toList());</span>
<span class="fc" id="L559">        BuilderWriter.write(out, fields, cls.simpleName(), useOf);</span>
<span class="fc" id="L560">    }</span>
    
    private static void writeNonDiscriminatedBuilder(CodePrintWriter out, Cls cls) {
<span class="fc" id="L563">        cls.fields.forEach(f -&gt; {</span>
<span class="fc" id="L564">            out.println();</span>
<span class="fc" id="L565">            out.line(&quot;public static %s of(%s value) {&quot;, cls.simpleName(), out.add(f.fullClassName));</span>
<span class="fc" id="L566">            out.line(&quot;return new %s(value);&quot;, cls.simpleName());</span>
<span class="fc" id="L567">            out.closeParen();</span>
<span class="fc" id="L568">        });</span>
<span class="fc" id="L569">    }</span>

    private static void writeOneOfAnyOfNonDiscriminatedMemberSpecificConstructor(CodePrintWriter out, Cls cls,
            Field f) {
<span class="fc" id="L573">        String className = toPrimitive(f.fullClassName);</span>
<span class="fc" id="L574">        out.println();</span>
<span class="fc" id="L575">        out.line(&quot;public %s(%s value) {&quot;, cls.simpleName(), out.add(className));</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (org.davidmoten.oa3.codegen.generator.internal.Util.isPrimitiveFullClassName(className)) {</span>
<span class="fc" id="L577">            out.line(&quot;this.value = value;&quot;);</span>
        } else {
<span class="fc" id="L579">            out.line(&quot;this.value = %s.checkNotNull(value, \&quot;value\&quot;);&quot;, Preconditions.class);</span>
        }
<span class="fc" id="L581">        out.closeParen();</span>
<span class="fc" id="L582">    }</span>

    private static void writeOneOfAnyOfNonDiscriminatedObjectConstructor(CodePrintWriter out, Cls cls) {
<span class="fc" id="L585">        out.println();</span>
<span class="fc" id="L586">        out.line(&quot;private %s(%s value) {&quot;, cls.simpleName(), Object.class);</span>
<span class="fc" id="L587">        out.line(&quot;this.value = %s.checkNotNull(value, \&quot;value\&quot;);&quot;, Preconditions.class);</span>
<span class="fc" id="L588">        out.closeParen();</span>
<span class="fc" id="L589">    }</span>

    private static void writeFields(CodePrintWriter out, Cls cls) {
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">        if (!cls.fields.isEmpty()) {</span>
<span class="fc" id="L593">            out.println();</span>
        }
<span class="fc" id="L595">        Mutable&lt;Boolean&gt; first = Mutable.create(true);</span>
<span class="fc" id="L596">        cls.fields.forEach(f -&gt; {</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (!first.value) {</span>
<span class="fc" id="L598">                out.println();</span>
            }
<span class="fc" id="L600">            first.value = false;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (cls.classType != ClassType.ANY_OF_NON_DISCRIMINATED) {</span>
<span class="pc bpc" id="L602" title="1 of 4 branches missed.">                if (f.isAdditionalProperties() &amp;&amp; !f.isArray) {</span>
<span class="fc" id="L603">                    out.line(&quot;@%s&quot;, JsonAnyGetter.class);</span>
<span class="fc" id="L604">                    out.line(&quot;@%s&quot;, JsonAnySetter.class);</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                } else if (cls.classType == ClassType.ALL_OF) {</span>
<span class="fc" id="L606">                    out.line(&quot;@%s&quot;, JsonUnwrapped.class);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                } else if (cls.unwrapSingleField()) {</span>
<span class="fc" id="L608">                    writeJsonValueAnnotation(out);</span>
                } else {
<span class="fc" id="L610">                    out.line(&quot;@%s(\&quot;%s\&quot;)&quot;, JsonProperty.class, f.name);</span>
                }
            }
<span class="fc bfc" id="L613" title="All 4 branches covered.">            if (f.required &amp;&amp; f.nullable) {</span>
<span class="fc" id="L614">                out.line(&quot;@%s(%s.ALWAYS)&quot;, JsonInclude.class, JsonInclude.Include.class);</span>
            }
<span class="fc bfc" id="L616" title="All 2 branches covered.">            if (f.isOctets()) {</span>
                // TODO handle f.isArray (more serializers?)
<span class="pc bpc" id="L618" title="1 of 4 branches missed.">                if (!f.required &amp;&amp; f.nullable) {</span>
<span class="nc" id="L619">                    out.line(&quot;@%s(using = %s.class)&quot;, JsonSerialize.class, JsonNullableOctetsSerializer.class);</span>
<span class="pc bpc" id="L620" title="1 of 4 branches missed.">                } else if (!f.required || f.nullable) {</span>
<span class="fc" id="L621">                    out.line(&quot;@%s(using = %s.class)&quot;, JsonSerialize.class, OptionalOctetsSerializer.class);</span>
                } else {
<span class="fc" id="L623">                    out.line(&quot;@%s(using = %s.class)&quot;, JsonSerialize.class, OctetsSerializer.class);</span>
                }
            }
            final String fieldType;
<span class="fc bfc" id="L627" title="All 4 branches covered.">            if (cls.classType == ClassType.ENUM &amp;&amp; cls.enumValueFullType.equals(Map.class.getCanonicalName())) {</span>
<span class="fc" id="L628">                fieldType = String.format(&quot;%s&lt;%s, %s&gt;&quot;, out.add(Map.class), out.add(String.class),</span>
<span class="fc" id="L629">                        out.add(Object.class));</span>
            } else {
<span class="fc" id="L631">                fieldType = f.resolvedType(out.imports());</span>
            }
<span class="fc" id="L633">            out.line(&quot;private final %s %s;&quot;, fieldType, cls.fieldName(f));</span>
<span class="fc" id="L634">        });</span>
<span class="fc" id="L635">    }</span>

    private static void writeJsonValueAnnotation(CodePrintWriter out) {
<span class="fc" id="L638">        out.line(&quot;@%s&quot;, JsonValue.class);</span>
<span class="fc" id="L639">    }</span>

    private static void writeConstructor(CodePrintWriter out, Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces,
            Names names) {

<span class="fc" id="L644">        Set&lt;Cls&gt; interfaces = interfaces(cls, fullClassNameInterfaces);</span>

<span class="fc" id="L646">        boolean hasAdditionalProperties = cls.fields.stream().anyMatch(Field::isAdditionalProperties);</span>
<span class="fc" id="L647">        boolean hasDiscriminator = cls.fields.stream().anyMatch(x -&gt; isDiscriminator(interfaces, x));</span>
<span class="fc" id="L648">        boolean extraConstructor = hasAdditionalProperties;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">        if (extraConstructor) {</span>
            // if has additionalProperties then we make the JsonCreator constructor private
            // (excluding properties) and make another public constructor that includes the
            // Map for additional properties as a parameter)
<span class="fc" id="L653">            out.right().right();</span>
<span class="fc" id="L654">            String parameters = cls //</span>
                    .fields //
<span class="fc" id="L656">                    .stream() //</span>
                    // ignore discriminators that should be constants
//                    .filter(x -&gt; !isDiscriminator(interfaces, x)) //
<span class="fc" id="L659">                    .map(x -&gt; {</span>
                        final String t;
<span class="fc bfc" id="L661" title="All 2 branches covered.">                        if (x.mapType.isPresent()) {</span>
<span class="fc" id="L662">                            t = x.resolvedTypeMapPublic(out.imports());</span>
                        } else {
<span class="fc" id="L664">                            t = x.resolvedTypePublicConstructor(out.imports());</span>
                        }
<span class="fc" id="L666">                        return String.format(&quot;\n%s%s %s&quot;, out.indent(), t, x.fieldName(cls));</span>
                    }) //
<span class="fc" id="L668">                    .collect(Collectors.joining(&quot;,&quot;));</span>
<span class="fc" id="L669">            out.left().left();</span>
<span class="fc" id="L670">            out.println();</span>
<span class="fc" id="L671">            out.line(&quot;public %s(%s) {&quot;, Names.simpleClassName(cls.fullClassName), parameters);</span>
<span class="fc" id="L672">            writeConstructorBody(out, cls, names, interfaces, true);</span>
<span class="fc" id="L673">            out.closeParen();</span>
        }
<span class="fc" id="L675">        out.right().right();</span>
<span class="fc" id="L676">        String parameters = cls //</span>
                .fields //
<span class="fc" id="L678">                .stream() //</span>
                // ignore discriminators that should be constants
//                    .filter(x -&gt; !isDiscriminator(interfaces, x)) //
<span class="fc bfc" id="L681" title="All 2 branches covered.">                .filter(x -&gt; !x.isAdditionalProperties()) //</span>
<span class="fc" id="L682">                .map(f -&gt; {</span>
                    final String t;
<span class="fc bfc" id="L684" title="All 2 branches covered.">                    if (f.mapType.isPresent()) {</span>
<span class="fc" id="L685">                        t = f.resolvedTypeMapPublic(out.imports());</span>
                    } else {
<span class="fc" id="L687">                        t = f.resolvedTypePublicConstructor(out.imports());</span>
                    }
<span class="fc bfc" id="L689" title="All 2 branches covered.">                    String annotations = cls.unwrapSingleField() ? &quot;&quot; //</span>
<span class="fc" id="L690">                            : String.format(&quot;@%s(\&quot;%s\&quot;) &quot;, out.add(JsonProperty.class), f.name);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">                    if (f.isOctets()) {</span>
<span class="pc bpc" id="L692" title="1 of 4 branches missed.">                        if (!f.required &amp;&amp; f.nullable) {</span>
<span class="nc" id="L693">                            annotations += String.format(&quot;@%s(using = %s.class) &quot;, out.add(JsonDeserialize.class),</span>
<span class="nc" id="L694">                                    out.add(JsonNullableOctetsDeserializer.class));</span>
<span class="pc bpc" id="L695" title="1 of 4 branches missed.">                        } else if (!f.required || f.nullable) {</span>
<span class="fc" id="L696">                            annotations += String.format(&quot;@%s(using = %s.class) &quot;, out.add(JsonDeserialize.class),</span>
<span class="fc" id="L697">                                    out.add(OptionalOctetsDeserializer.class));</span>
                        } else {
<span class="fc" id="L699">                            annotations += String.format(&quot;@%s(using = %s.class) &quot;, out.add(JsonDeserialize.class),</span>
<span class="fc" id="L700">                                    out.add(OctetsDeserializer.class));</span>
                        }
                    }
<span class="fc" id="L703">                    return String.format(&quot;\n%s%s%s %s&quot;, out.indent(), annotations, t, f.fieldName(cls));</span>
                }) //
<span class="fc" id="L705">                .collect(Collectors.joining(&quot;,&quot;));</span>
<span class="fc" id="L706">        out.left().left();</span>
<span class="fc" id="L707">        out.println();</span>
        final String modifier;
<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (cls.classType == ClassType.ENUM) {</span>
<span class="fc" id="L710">            modifier = &quot;&quot;;</span>
<span class="fc bfc" id="L711" title="All 4 branches covered.">        } else if (hasDiscriminator||extraConstructor) {</span>
<span class="fc" id="L712">            modifier = &quot;private &quot;;</span>
        } else {
<span class="fc" id="L714">            modifier = &quot;public &quot;;</span>
        }
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if (modifier.equals(&quot;private &quot;)) {</span>
<span class="fc" id="L717">            addConstructorBindingAnnotation(out, names);</span>
        }
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (cls.classType != ClassType.ENUM) {</span>
<span class="fc" id="L720">            out.line(&quot;@%s&quot;, JsonCreator.class);</span>
        }
<span class="fc" id="L722">        out.line(&quot;%s%s(%s) {&quot;, modifier, Names.simpleClassName(cls.fullClassName), parameters);</span>
<span class="fc" id="L723">        writeConstructorBody(out, cls, names, interfaces, false);</span>
<span class="fc" id="L724">        out.closeParen();</span>
<span class="fc" id="L725">    }</span>

    private static void addConstructorBindingAnnotation(CodePrintWriter out, Names names) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (names.generateService()) {</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">            if (names.generatorType() == ServerGeneratorType.SPRING3) {</span>
<span class="nc" id="L730">                out.line(&quot;@%s&quot;, out</span>
<span class="nc" id="L731">                        .add(ConstructorBinding.class.getName().replace(&quot;ConstructorBinding&quot;, &quot;bind.ConstructorBinding&quot;)));</span>
            } else {
<span class="fc" id="L733">                out.line(&quot;@%s&quot;, ConstructorBinding.class);</span>
            }
        }
<span class="fc" id="L736">    }</span>

    private static void writeConstructorBody(CodePrintWriter out, Cls cls, Names names, Set&lt;Cls&gt; interfaces,
            boolean additionalPropertiesIsParameter) {
        // validate
<span class="fc" id="L741">        ifValidate(cls, out, names, //</span>
<span class="fc" id="L742">                out2 -&gt; cls.fields.stream() //</span>
<span class="fc bfc" id="L743" title="All 4 branches covered.">                        .filter(x -&gt; !x.isAdditionalProperties() || additionalPropertiesIsParameter) //</span>
<span class="fc" id="L744">                        .forEach(x -&gt; {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">                            if (!isDiscriminator(interfaces, x)) {</span>
<span class="fc bfc" id="L746" title="All 4 branches covered.">                                if (x.isOctets() || !x.isPrimitive()) {</span>
<span class="fc" id="L747">                                    checkNotNull(cls, out2, x);</span>
                                }
<span class="fc" id="L749">                                validateMore(out2, cls, x);</span>
                            }
<span class="fc" id="L751">                        }));</span>
        // assign
<span class="fc" id="L753">        cls //</span>
                .fields //
<span class="fc" id="L755">                .stream() //</span>
<span class="fc" id="L756">                .forEach(x -&gt; writeConstructorBodyFieldAssignment(out, cls, interfaces, x,</span>
                        additionalPropertiesIsParameter));
<span class="fc" id="L758">    }</span>

    private static void writeConstructorBodyFieldAssignment(CodePrintWriter out, Cls cls, Set&lt;Cls&gt; interfaces, Field x,
            boolean additionalPropertiesIsParameter) {
<span class="fc bfc" id="L762" title="All 4 branches covered.">        if (x.isAdditionalProperties() &amp;&amp; !additionalPropertiesIsParameter) {</span>
<span class="fc" id="L763">            out.line(&quot;this.%s = new %s&lt;&gt;();&quot;, x.fieldName(cls), HashMap.class);</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        } else if (x.mapType.isPresent()) {</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">            if (x.isArray) {</span>
<span class="fc" id="L766">                out.line(&quot;this.%s = new %s&lt;&gt;();&quot;, x.fieldName(cls), ArrayList.class);</span>
<span class="fc bfc" id="L767" title="All 4 branches covered.">            } else if (x.required &amp;&amp; !x.nullable) {</span>
<span class="fc" id="L768">                out.line(&quot;this.%s = %s.createMapIfNull(%s);&quot;, x.fieldName(cls), Util.class, x.fieldName(cls));</span>
            } else {
<span class="fc" id="L770">                out.line(&quot;this.%s = %s;&quot;, x.fieldName(cls), x.fieldName(cls));</span>
            }
<span class="fc" id="L772">            return;</span>
        } else {
<span class="fc" id="L774">            Optional&lt;Discriminator&gt; disc = discriminator(interfaces, x);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">            if (disc.isPresent()) {</span>
                // write constant value for discriminator, if is enum then
                // grab it's value using the DiscriminatorHelper
<span class="fc" id="L778">                out.line(&quot;%s.checkEquals(%s.value(%s.class, \&quot;%s\&quot;), %s, \&quot;%s\&quot;);&quot;, //</span>
                        Preconditions.class, //
                        DiscriminatorHelper.class, //
<span class="fc" id="L781">                        out.add(x.fullClassName), //</span>
<span class="fc" id="L782">                        disc.get().discriminatorValueFromFullClassName(cls.fullClassName), //</span>
<span class="fc" id="L783">                        x.fieldName(cls), //</span>
<span class="fc" id="L784">                        x.fieldName(cls));</span>
<span class="fc" id="L785">                out.line(&quot;this.%s = %s;&quot;, x.fieldName(cls), x.fieldName(cls));</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">            } else if (x.nullable) {</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                if (x.required) {</span>
<span class="fc" id="L788">                    out.line(&quot;this.%s = %s;&quot;, x.fieldName(cls), x.fieldName(cls));</span>
                } else {
<span class="fc" id="L790">                    assignField(out, cls, x);</span>
                }
<span class="fc bfc" id="L792" title="All 2 branches covered.">            } else if (!x.isPrimitive()) {</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">                if (x.required) {</span>
<span class="fc" id="L794">                    assignField(out, cls, x);</span>
                } else {
<span class="fc" id="L796">                    assignOptionalField(out, cls, x);</span>
                }
            } else {
<span class="fc" id="L799">                assignField(out, cls, x);</span>
            }
        }
<span class="fc" id="L802">    }</span>

    private static Set&lt;Cls&gt; interfaces(Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces) {
<span class="fc" id="L805">        Set&lt;Cls&gt; interfaces = Util.orElse(fullClassNameInterfaces.get(cls.fullClassName), Collections.emptySet());</span>
<span class="fc" id="L806">        return interfaces;</span>
    }

    private static void writeBuilder(CodePrintWriter out, Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces) {
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (cls.classType == ClassType.ENUM) {</span>
<span class="fc" id="L811">            return;</span>
        }
<span class="fc" id="L813">        Set&lt;Cls&gt; interfaces = Util.orElse(fullClassNameInterfaces.get(cls.fullClassName), Collections.emptySet());</span>
<span class="fc" id="L814">        List&lt;BuilderWriter.Field&gt; fields = cls.fields //</span>
<span class="fc" id="L815">                .stream() //</span>
//                .filter(x -&gt; !isDiscriminator(interfaces, x)) //
<span class="fc" id="L817">                .map(f -&gt; {</span>
                    Optional&lt;Function&lt;String, String&gt;&gt; expressionFactory;
<span class="fc" id="L819">                    Optional&lt;Discriminator&gt; disc = discriminator(interfaces, f);</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">                    if (disc.isPresent()) {</span>
                        // write constant value for discriminator, if is enum then
                        // grab it's value using the DiscriminatorHelper
<span class="fc" id="L823">                        String expression = String.format(&quot;%s.value(%s.class, \&quot;%s\&quot;)&quot;, </span>
<span class="fc" id="L824">                                out.add(DiscriminatorHelper.class), </span>
<span class="fc" id="L825">                                out.add(f.fullClassName),</span>
<span class="fc" id="L826">                                disc.get().discriminatorValueFromFullClassName(cls.fullClassName));</span>
<span class="fc" id="L827">                        expressionFactory = Optional.of(x -&gt; expression);</span>
<span class="fc" id="L828">                    } else {</span>
<span class="fc" id="L829">                        expressionFactory = Optional.empty();</span>
                    }
<span class="fc bfc" id="L831" title="All 2 branches covered.">                    return new BuilderWriter.Field(f.fieldName(cls), f.fullClassName,</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">                        f.required &amp;&amp; !f.isAdditionalProperties(), f.isArray, f.mapType, f.nullable, expressionFactory);})</span>
<span class="fc" id="L833">                .collect(Collectors.toList());</span>
<span class="fc" id="L834">        BuilderWriter.write(out, fields, cls.simpleName());</span>
<span class="fc" id="L835">    }</span>

    private static void checkNotNull(Cls cls, CodePrintWriter out, Field x) {
<span class="fc" id="L838">        out.line(&quot;%s.checkNotNull(%s, \&quot;%s\&quot;);&quot;, Preconditions.class, x.fieldName(cls), x.fieldName(cls));</span>
<span class="fc" id="L839">    }</span>

    private static void assignOptionalField(CodePrintWriter out, Cls cls, Field x) {
<span class="fc" id="L842">        out.line(&quot;this.%s = %s;&quot;, x.fieldName(cls), x.fieldName(cls));</span>
<span class="fc" id="L843">    }</span>

    private static boolean isDiscriminator(Set&lt;Cls&gt; interfaces, Field x) {
<span class="fc" id="L846">        return discriminator(interfaces, x).isPresent();</span>
    }

    private static Optional&lt;Discriminator&gt; discriminator(Set&lt;Cls&gt; interfaces, Field x) {
<span class="fc" id="L850">        return interfaces.stream().filter(y -&gt; x.name.equals(y.discriminator.propertyName)) //</span>
<span class="fc" id="L851">                .map(y -&gt; y.discriminator).findFirst();</span>
    }

    private static void validateMore(CodePrintWriter out, Cls cls, Field x) {
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (x.isAdditionalProperties()) {</span>
            // TODO check values of map
<span class="fc" id="L857">            return;</span>
        }
<span class="fc" id="L859">        String raw = x.fieldName(cls);</span>
<span class="pc bpc" id="L860" title="1 of 4 branches missed.">        if (x.minLength.isPresent() &amp;&amp; !x.isDateOrTime()) {</span>
<span class="fc" id="L861">            out.line(&quot;%s.checkMinLength(%s, %s, \&quot;%s\&quot;);&quot;, Preconditions.class, raw, x.minLength.get(),</span>
<span class="fc" id="L862">                    x.fieldName(cls));</span>
        }
<span class="pc bpc" id="L864" title="1 of 4 branches missed.">        if (x.maxLength.isPresent() &amp;&amp; !x.isDateOrTime()) {</span>
<span class="fc" id="L865">            out.line(&quot;%s.checkMaxLength(%s, %s, \&quot;%s\&quot;);&quot;, Preconditions.class, raw, x.maxLength.get(),</span>
<span class="fc" id="L866">                    x.fieldName(cls));</span>
        }
<span class="pc bpc" id="L868" title="3 of 8 branches missed.">        if (x.pattern.isPresent() &amp;&amp; !x.isDateOrTime() &amp;&amp; !x.isByteArray() &amp;&amp; !x.isOctets()) {</span>
<span class="fc" id="L869">            out.line(&quot;%s.checkMatchesPattern(%s, \&quot;%s\&quot;, \&quot;%s\&quot;);&quot;, Preconditions.class, raw,</span>
<span class="fc" id="L870">                    WriterUtil.escapePattern(x.pattern.get()), x.fieldName(cls));</span>
        }
<span class="fc bfc" id="L872" title="All 4 branches covered.">        if (x.min.isPresent() &amp;&amp; x.isNumber()) {</span>
<span class="fc" id="L873">            out.line(&quot;%s.checkMinimum(%s, \&quot;%s\&quot;, \&quot;%s\&quot;, %s);&quot;, Preconditions.class, raw, x.min.get().toString(),</span>
<span class="fc" id="L874">                    x.fieldName(cls), x.exclusiveMin);</span>
        }
<span class="fc bfc" id="L876" title="All 4 branches covered.">        if (x.max.isPresent() &amp;&amp; x.isNumber()) {</span>
<span class="fc" id="L877">            out.line(&quot;%s.checkMaximum(%s, \&quot;%s\&quot;, \&quot;%s\&quot;, %s);&quot;, Preconditions.class, raw, x.max.get().toString(),</span>
<span class="fc" id="L878">                    x.fieldName(cls), x.exclusiveMax);</span>
        }
<span class="fc bfc" id="L880" title="All 4 branches covered.">        if (x.isArray &amp;&amp; x.minItems.isPresent()) {</span>
<span class="fc" id="L881">            out.line(&quot;%s.checkMinSize(%s, %s, \&quot;%s\&quot;);&quot;, Preconditions.class, x.fieldName(cls), x.minItems.get(),</span>
<span class="fc" id="L882">                    x.fieldName(cls));</span>
        }
<span class="fc bfc" id="L884" title="All 4 branches covered.">        if (x.isArray &amp;&amp; x.maxItems.isPresent()) {</span>
<span class="fc" id="L885">            out.line(&quot;%s.checkMaxSize(%s, %s, \&quot;%s\&quot;);&quot;, Preconditions.class, x.fieldName(cls), x.maxItems.get(),</span>
<span class="fc" id="L886">                    x.fieldName(cls));</span>
        }
<span class="fc" id="L888">    }</span>

    private static void writeEqualsMethod(CodePrintWriter out, Cls cls) {
<span class="fc" id="L891">        addOverrideAnnotation(out);</span>
<span class="fc" id="L892">        out.line(&quot;public boolean equals(%s o) {&quot;, Object.class);</span>
<span class="fc" id="L893">        out.line(&quot;if (this == o) {&quot;);</span>
<span class="fc" id="L894">        out.line(&quot;return true;&quot;);</span>
<span class="fc" id="L895">        out.closeParen();</span>
<span class="fc" id="L896">        out.line(&quot;if (o == null || getClass() != o.getClass()) {&quot;);</span>
<span class="fc" id="L897">        out.line(&quot;return false;&quot;);</span>
<span class="fc" id="L898">        out.closeParen();</span>
<span class="fc" id="L899">        out.right();</span>
<span class="fc" id="L900">        String s = cls.fields</span>
<span class="fc" id="L901">                .stream() //</span>
<span class="fc" id="L902">                .map(x -&gt; String.format(&quot;\n%s%s.deepEquals(this.%s, other.%s)&quot;, out.indent(),</span>
<span class="fc" id="L903">                        out.add(Objects.class), x.fieldName(cls), x.fieldName(cls)))</span>
<span class="fc" id="L904">                .distinct()</span>
<span class="fc" id="L905">                .collect(Collectors.joining(&quot; &amp;&amp; &quot;));</span>
<span class="fc" id="L906">        out.left();</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">        if (!s.isEmpty()) {</span>
<span class="fc" id="L908">            out.line(&quot;%s other = (%s) o;&quot;, cls.simpleName(), cls.simpleName());</span>
        }
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        out.line(&quot;return %s;&quot;, s.isEmpty() ? &quot;true&quot; : s);</span>
<span class="fc" id="L911">        out.closeParen();</span>
<span class="fc" id="L912">    }</span>

    private static void writeHashCodeMethod(CodePrintWriter out, Cls cls) {
        final String s;
<span class="fc bfc" id="L916" title="All 2 branches covered.">        if (cls.fields.size() &lt;= 3) {</span>
<span class="fc" id="L917">            s = cls.fields.stream().map(x -&gt; x.fieldName(cls)).collect(Collectors.joining(&quot;, &quot;));</span>
        } else {
<span class="fc" id="L919">            out.right().right().right();</span>
<span class="fc" id="L920">            s = cls.fields.stream().map(x -&gt; String.format(&quot;\n%s%s&quot;, out.indent(), x.fieldName(cls)))</span>
<span class="fc" id="L921">                    .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L922">            out.left().left().left();</span>
        }
<span class="fc" id="L924">        addOverrideAnnotation(out);</span>
<span class="fc" id="L925">        out.line(&quot;public int hashCode() {&quot;);</span>
<span class="fc" id="L926">        out.line(&quot;return %s.hash(%s);&quot;, Objects.class, s);</span>
<span class="fc" id="L927">        out.closeParen();</span>
<span class="fc" id="L928">    }</span>

    private static void writeToStringMethod(CodePrintWriter out, Cls cls) {
        final String s;
<span class="fc bfc" id="L932" title="All 2 branches covered.">        if (cls.fields.size() &gt; 3) {</span>
<span class="fc" id="L933">            out.right().right().right();</span>
<span class="fc" id="L934">            s = cls.fields.stream()</span>
<span class="fc" id="L935">                    .map(x -&gt; String.format(&quot;,\n%s\&quot;%s\&quot;, %s&quot;, out.indent(), x.fieldName(cls), x.fieldName(cls)))</span>
<span class="fc" id="L936">                    .collect(Collectors.joining());</span>
<span class="fc" id="L937">            out.left().left().left();</span>
        } else {
<span class="fc" id="L939">            s = cls.fields.stream().map(x -&gt; String.format(&quot;, \&quot;%s\&quot;, %s&quot;, x.fieldName(cls), x.fieldName(cls)))</span>
<span class="fc" id="L940">                    .collect(Collectors.joining(&quot;&quot;));</span>
        }
<span class="fc" id="L942">        addOverrideAnnotation(out);</span>
<span class="fc" id="L943">        out.line(&quot;public %s toString() {&quot;, String.class);</span>
<span class="fc" id="L944">        out.line(&quot;return %s.toString(%s.class%s);&quot;, Util.class, cls.simpleName(), s);</span>
<span class="fc" id="L945">        out.closeParen();</span>
<span class="fc" id="L946">    }</span>

    private static void ifValidate(Cls cls, CodePrintWriter out, Names names, Consumer&lt;CodePrintWriter&gt; consumer) {
<span class="fc" id="L949">        CodePrintWriter b = CodePrintWriter.create(out);</span>
<span class="fc" id="L950">        out.right();</span>
<span class="fc" id="L951">        consumer.accept(b);</span>
<span class="fc" id="L952">        out.left();</span>
<span class="fc" id="L953">        b.close();</span>
<span class="fc" id="L954">        String text = b.text();</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (text.isEmpty()) {</span>
<span class="fc" id="L956">            return;</span>
        } else {
<span class="fc" id="L958">            out.line(&quot;if (%s.config().validateInConstructor().test(%s.class)) {&quot;, out.add(names.globalsFullClassName()),</span>
<span class="fc" id="L959">                    cls.simpleName());</span>
<span class="fc" id="L960">            out.left();</span>
<span class="fc" id="L961">            out.print(text);</span>
<span class="fc" id="L962">            out.line(&quot;}&quot;);</span>
        }
<span class="fc" id="L964">    }</span>

    private static void assignField(CodePrintWriter out, Cls cls, Field x) {
<span class="fc" id="L967">        out.line(&quot;this.%s = %s;&quot;, x.fieldName(cls), x.fieldName(cls));</span>
<span class="fc" id="L968">    }</span>

    private static void writeGetters(CodePrintWriter out, Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces) {
<span class="fc" id="L971">        Set&lt;Cls&gt; interfaces = Util.orElse(fullClassNameInterfaces.get(cls.fullClassName), Collections.emptySet());</span>
<span class="fc" id="L972">        cls.fields.forEach(f -&gt; {</span>
<span class="fc" id="L973">            out.println();</span>
<span class="fc" id="L974">            Optional&lt;Discriminator&gt; disc = discriminator(interfaces, f);</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">            if (disc.isPresent()) {</span>
                // write constant value for discriminator, if is enum then
                // grab it's value using the DiscriminatorHelper
<span class="fc" id="L978">                String value = discriminatorHelperExpression(out, f.fieldName(cls));</span>
<span class="fc" id="L979">                addOverrideAnnotation(out);</span>
<span class="fc" id="L980">                writeGetter(out, out.add(String.class), f.fieldName(cls), value);</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">            } else if (f.mapType.isPresent()) {</span>
<span class="fc bfc" id="L982" title="All 4 branches covered.">                if (!f.isArray &amp;&amp; f.isAdditionalProperties()) {</span>
<span class="fc" id="L983">                    writeJsonAnySetter(out, cls, f);</span>
                }
<span class="fc" id="L985">                final String expression = f.fieldName(cls);</span>
<span class="fc" id="L986">                writeGetter(out, f.resolvedTypeMapPublic(out.imports()), f.fieldName(cls), expression);</span>
<span class="fc" id="L987">            } else {</span>
<span class="fc" id="L988">                final String value = f.fieldName(cls);</span>
                final String returnType;
<span class="fc bfc" id="L990" title="All 4 branches covered.">                if (cls.classType == ClassType.ENUM &amp;&amp; f.fullClassName.equals(Map.class.getCanonicalName())) {</span>
<span class="fc" id="L991">                    returnType = String.format(&quot;%s&lt;%s, %s&gt;&quot;, out.add(Map.class), out.add(String.class), out.add(Object.class));</span>
                } else {
<span class="fc" id="L993">                    returnType = f.resolvedTypePublicConstructor(out.imports());</span>
                }
<span class="fc" id="L995">                writeGetter(out, returnType, f.fieldName(cls), value);</span>
            }
<span class="fc" id="L997">        });</span>

<span class="fc" id="L999">    }</span>

    private static String discriminatorHelperExpression(CodePrintWriter out, String fieldExpression) {
<span class="fc" id="L1002">        return String.format(&quot;%s.value(%s)&quot;, out.add(DiscriminatorHelper.class), fieldExpression);</span>
    }
    
    private static void writePropertiesMapGetter(CodePrintWriter out, Cls cls) {
<span class="pc bpc" id="L1006" title="1 of 4 branches missed.">        if (cls.fields.isEmpty() || cls.classType == ClassType.ENUM) {</span>
<span class="fc" id="L1007">            return;</span>
        }
<span class="fc" id="L1009">        Indent indent = out.indent().copy().right().right().right();</span>
<span class="fc" id="L1010">        String puts = cls.fields.stream().map(f -&gt; String.format(&quot;\n%s.put(\&quot;%s\&quot;, (%s) %s)&quot;, indent, f.name, out.add(Object.class), cls.fieldName(f))).collect(Collectors.joining());</span>
<span class="fc" id="L1011">        out.println();</span>
<span class="fc" id="L1012">        out.line(&quot;%s&lt;%s, %s&gt; _internal_properties() {&quot;, Map.class, String.class, Object.class);</span>
<span class="fc" id="L1013">        out.line(&quot;return %s%s\n%s.build();&quot;, Maps.class, puts, indent);</span>
<span class="fc" id="L1014">        out.closeParen();</span>
<span class="fc" id="L1015">    }</span>

    private static void writeMutators(CodePrintWriter out, Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces) {
<span class="fc" id="L1018">        List&lt;Field&gt; fields = cls.fields //</span>
<span class="fc" id="L1019">                .stream() //</span>
<span class="fc" id="L1020">                .collect(Collectors.toList());</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        if (fields.size() &lt;= 1) {</span>
<span class="fc" id="L1022">            return;</span>
        }
<span class="fc" id="L1024">        fields //</span>
<span class="fc" id="L1025">                .stream() //</span>
                // ignore discriminators that should be constants so don't need a mutator
<span class="fc bfc" id="L1027" title="All 2 branches covered.">                .filter(x -&gt; !isDiscriminator(interfaces(cls, fullClassNameInterfaces), x)) //</span>
<span class="fc" id="L1028">                .forEach(x -&gt; {</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">                    String t = x.mapType.isPresent() ? x.resolvedTypeMapPublic(out.imports())</span>
<span class="fc" id="L1030">                            : x.resolvedTypePublicConstructor(out.imports());</span>
<span class="fc" id="L1031">                    out.println();</span>
<span class="fc" id="L1032">                    out.line(&quot;public %s with%s(%s %s) {&quot;, cls.simpleName(), Names.upperFirst(x.fieldName(cls)), t,</span>
<span class="fc" id="L1033">                            x.fieldName(cls));</span>
                    {
<span class="fc" id="L1035">                        String params = fields.stream() //</span>
<span class="fc" id="L1036">                                .map(y -&gt; y.fieldName(cls)) //</span>
<span class="fc" id="L1037">                                .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L1038">                        out.line(&quot;return new %s(%s);&quot;, cls.simpleName(), params);</span>
<span class="fc" id="L1039">                        out.closeParen();</span>
                    }
<span class="fc bfc" id="L1041" title="All 2 branches covered.">                    if (!x.mapType.isPresent()) {</span>
<span class="fc" id="L1042">                        Optional&lt;String&gt; tNonOptional = x.resolvedTypePublicConstructorNonOptional(out.imports());</span>
<span class="pc bpc" id="L1043" title="1 of 4 branches missed.">                        if (tNonOptional.isPresent() &amp;&amp; !tNonOptional.get().equals(t)) {</span>
<span class="fc" id="L1044">                            out.println();</span>
<span class="fc" id="L1045">                            out.line(&quot;public %s with%s(%s %s) {&quot;, cls.simpleName(), Names.upperFirst(x.fieldName(cls)),</span>
<span class="fc" id="L1046">                                    tNonOptional.get(), x.fieldName(cls));</span>
<span class="fc" id="L1047">                            String params = fields.stream() //</span>
<span class="fc" id="L1048">                                    .map(y -&gt; {</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">                                        if (y.fieldName(cls).equals(x.fieldName(cls))) {</span>
<span class="fc bfc" id="L1050" title="All 4 branches covered.">                                            if (y.nullable &amp;&amp; !y.required) {</span>
<span class="fc" id="L1051">                                                return String.format(&quot;%s.of(%s)&quot;, out.add(JsonNullable.class),</span>
<span class="fc" id="L1052">                                                        y.fieldName(cls));</span>
                                            } else {
<span class="fc" id="L1054">                                                return String.format(&quot;%s.of(%s)&quot;, out.add(Optional.class),</span>
<span class="fc" id="L1055">                                                        y.fieldName(cls));</span>
                                            }
                                        } else {
<span class="fc" id="L1058">                                            return y.fieldName(cls);</span>
                                        }
<span class="fc" id="L1060">                                    }).collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L1061">                            out.line(&quot;return new %s(%s);&quot;, cls.simpleName(), params);</span>
<span class="fc" id="L1062">                            out.closeParen();</span>
                        }
                    }
<span class="fc" id="L1065">                });</span>
<span class="fc" id="L1066">    }</span>

    private static void writeJsonAnySetter(CodePrintWriter out, Cls cls, Field f) {
<span class="fc" id="L1069">        out.println();</span>
<span class="fc" id="L1070">        out.line(&quot;@%s&quot;, JsonAnySetter.class);</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        if (f.nullable) {</span>
<span class="fc" id="L1072">            out.line(&quot;private void put(%s key, %s&lt;%s&gt; value) {&quot;, String.class, JsonNullable.class,</span>
<span class="fc" id="L1073">                    out.add(f.fullClassName));</span>
        } else {
<span class="fc" id="L1075">            out.line(&quot;private void put(%s key, %s value) {&quot;, String.class, out.add(f.fullClassName));</span>
        }
<span class="fc" id="L1077">        out.line(&quot;this.%s.put(key, value);&quot;, f.fieldName(cls));</span>
<span class="fc" id="L1078">        out.closeParen();</span>
<span class="fc" id="L1079">    }</span>

    private static void writeGetter(CodePrintWriter out, String returnImportedType, String fieldName, String value) {
<span class="fc" id="L1082">        out.line(&quot;public %s %s() {&quot;, returnImportedType, fieldName);</span>
<span class="fc" id="L1083">        out.line(&quot;return %s;&quot;, value);</span>
<span class="fc" id="L1084">        out.closeParen();</span>
<span class="fc" id="L1085">    }</span>

    private static void writeMemberClasses(CodePrintWriter out, Cls cls, Map&lt;String, Set&lt;Cls&gt;&gt; fullClassNameInterfaces,
            Names names) {
<span class="fc" id="L1089">        cls.classes.forEach(c -&gt; writeClass(out, c, fullClassNameInterfaces, names));</span>
<span class="fc" id="L1090">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>