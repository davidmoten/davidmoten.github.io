<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientServerGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">openapi-codegen-generator</a> &gt; <a href="index.source.html" class="el_package">org.davidmoten.oa3.codegen.generator</a> &gt; <span class="el_source">ClientServerGenerator.java</span></div><h1>ClientServerGenerator.java</h1><pre class="source lang-java linenums">package org.davidmoten.oa3.codegen.generator;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.davidmoten.oa3.codegen.generator.Generator.Cls;
import org.davidmoten.oa3.codegen.generator.Generator.MyVisitor;
import org.davidmoten.oa3.codegen.generator.Generator.MyVisitor.Result;
import org.davidmoten.oa3.codegen.generator.internal.Mutable;
import org.davidmoten.oa3.codegen.generator.internal.Util;
import org.davidmoten.oa3.codegen.generator.writer.ClientCodeWriter;
import org.davidmoten.oa3.codegen.generator.writer.ServerCodeWriterSpringBoot;
import org.davidmoten.oa3.codegen.util.ImmutableList;

import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.PathItem.HttpMethod;
import io.swagger.v3.oas.models.media.Content;
import io.swagger.v3.oas.models.media.MediaType;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.parameters.CookieParameter;
import io.swagger.v3.oas.models.parameters.HeaderParameter;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.parameters.PathParameter;
import io.swagger.v3.oas.models.parameters.QueryParameter;
import io.swagger.v3.oas.models.parameters.RequestBody;
import io.swagger.v3.oas.models.responses.ApiResponse;
import io.swagger.v3.oas.models.responses.ApiResponses;

public class ClientServerGenerator {

    private final Names names;
    private final Map&lt;String, Cls&gt; refCls;
    private final Map&lt;Schema&lt;?&gt;, Cls&gt; schemaCls;

<span class="fc" id="L45">    public ClientServerGenerator(Definition definition) {</span>
<span class="fc" id="L46">        this.names = new Names(definition);</span>
        // make a ref map
<span class="fc" id="L48">        Map&lt;String, Cls&gt; refCls = new HashMap&lt;&gt;();</span>
<span class="fc" id="L49">        Map&lt;Schema&lt;?&gt;, Cls&gt; schemaCls = new HashMap&lt;&gt;();</span>
<span class="fc" id="L50">        MyVisitor v = new MyVisitor(names);</span>
<span class="fc" id="L51">        Apis.visitSchemas(names.api(), v);</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">        for (Result result : v.results()) {</span>
<span class="fc" id="L53">            Cls c = result.cls;</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">            if (c.topLevel) {</span>
<span class="fc" id="L55">                String refPrefix = c.category.refPrefix();</span>
<span class="fc" id="L56">                String ref = refPrefix + c.name.get();</span>
<span class="fc" id="L57">                refCls.put(ref, c);</span>
<span class="fc" id="L58">                schemaCls.put(c.schema.get(), c);</span>
            }
<span class="fc" id="L60">        }</span>
<span class="fc" id="L61">        this.refCls = refCls;</span>
<span class="fc" id="L62">        this.schemaCls = schemaCls;</span>
<span class="fc" id="L63">    }</span>

    public void generateServer() {
<span class="fc" id="L66">        List&lt;Method&gt; methods = collectMethods();</span>
<span class="fc" id="L67">        ServerCodeWriterSpringBoot.writeServiceClasses(names, methods);</span>
<span class="fc" id="L68">    }</span>

    public void generateClient() {
<span class="fc" id="L71">        List&lt;Method&gt; methods = collectMethods();</span>
<span class="fc" id="L72">        ClientCodeWriter.writeClientClass(names, methods);</span>
<span class="fc" id="L73">    }</span>

    private List&lt;Method&gt; collectMethods() {
        // want a method per path, operation combo
<span class="fc" id="L77">        List&lt;Method&gt; methods = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (names.api().getPaths() != null) {</span>
<span class="fc" id="L79">            names.api().getPaths().forEach((pathName, pathItem) -&gt; gatherMethods(pathName, pathItem, methods));</span>
        }
<span class="fc" id="L81">        return methods;</span>
    }

    private void gatherMethods(String pathName, PathItem pathItem, List&lt;Method&gt; methods) {
<span class="fc" id="L85">        pathItem = Apis.resolveRefs(names.api(), pathItem);</span>
<span class="fc" id="L86">        pathItem.readOperationsMap() //</span>
<span class="fc" id="L87">                .forEach((method, operation) -&gt; gatherMethods(pathName, method, operation, methods));</span>
<span class="fc" id="L88">    }</span>
    
    private void gatherMethods(String pathName, HttpMethod method, Operation operation, List&lt;Method&gt; methods) {
        final String methodName;
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (!Util.isNullOrBlank(operation.getOperationId())) {</span>
<span class="fc" id="L93">            methodName = Names.toIdentifier(operation.getOperationId());</span>
        } else {
<span class="fc" id="L95">            methodName = Names.toIdentifier(ImmutableList.of(pathName, method.toString().toLowerCase(Locale.ENGLISH)));</span>
        }
<span class="fc" id="L97">        Optional&lt;String&gt; statusCode = Optional.empty();</span>
<span class="fc" id="L98">        List&lt;Param&gt; params = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L99">        Optional&lt;String&gt; returnFullClassName = Optional.empty();</span>
<span class="fc" id="L100">        List&lt;String&gt; consumes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L101">        List&lt;String&gt; produces = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L102">        Set&lt;String&gt; parameterNames = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (operation.getParameters() != null) {</span>
<span class="fc" id="L104">            operation.getParameters() //</span>
<span class="fc" id="L105">                    .forEach(p -&gt; {</span>
                        // TODO handle refs to components/headers
<span class="fc" id="L107">                        p = resolveParameterRefs(p);</span>
<span class="fc" id="L108">                        boolean isArray = false;</span>
<span class="fc" id="L109">                        Schema&lt;?&gt; s = p.getSchema();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">                        if (s == null) {</span>
                            // TODO do something with p.getContent() instead of schema
<span class="nc" id="L112">                            System.out.println(&quot;[WARN] parameter skipped because without schema (not yet supported): &quot; //</span>
<span class="nc" id="L113">                                    + operationName(pathName, method, operation));   </span>
<span class="nc" id="L114">                            return;</span>
                        }
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">                        if (p.getName().isEmpty()) {</span>
<span class="nc" id="L117">                            System.out.println(&quot;[WARN] parameter skipped because name empty: &quot; //</span>
<span class="nc" id="L118">                                    + operationName(pathName, method, operation));</span>
<span class="nc" id="L119">                            return;</span>
                        }
<span class="fc" id="L121">                        final Schema&lt;?&gt; resolvedOriginal = resolveRefs(s);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">                        if (Util.isArray(s)) {</span>
<span class="fc" id="L123">                            isArray = true;</span>
<span class="fc" id="L124">                            s = s.getItems();</span>
                        } 
<span class="fc" id="L126">                        s = resolveRefs(s);</span>
<span class="fc" id="L127">                        Optional&lt;Object&gt; defaultValue = Optional.ofNullable(s.getDefault());</span>
<span class="fc" id="L128">                        String parameterName = Names.toIdentifier(p.getName());</span>
<span class="fc" id="L129">                        int i = 2;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                        while (parameterNames.contains(parameterName)) {</span>
<span class="fc" id="L131">                            parameterName = Names.toIdentifier(p.getName()) + i;</span>
<span class="fc" id="L132">                            i++;</span>
                        }
<span class="fc" id="L134">                        parameterNames.add(parameterName);</span>
                        final Param param;
<span class="fc bfc" id="L136" title="All 4 branches covered.">                        if (Util.isPrimitive(s) &amp;&amp; !Util.isEnum(s)) {</span>
                            // handle simple schemas
<span class="fc" id="L138">                            Class&lt;?&gt; c = Util.toClass(Util.getTypeOrThrow(s), s.getFormat(), s.getExtensions(),</span>
<span class="fc" id="L139">                                    names.mapIntegerToBigInteger(), names.mapNumberToBigDecimal());</span>
<span class="fc" id="L140">                            param = new Param(p.getName(), parameterName, defaultValue, p.getRequired(),</span>
<span class="fc" id="L141">                                    c.getCanonicalName(), isArray, false, constraints(s), toParamType(p), false,</span>
<span class="fc" id="L142">                                    Optional.ofNullable(p.getDescription()), Optional.empty(), Optional.empty());</span>
<span class="fc" id="L143">                        } else {</span>
                            // is complex schema
<span class="fc" id="L145">                            Cls cls = schemaCls.get(resolvedOriginal);</span>
<span class="fc" id="L146">                            param = new Param(p.getName(), parameterName, defaultValue, p.getRequired(),</span>
<span class="fc" id="L147">                                    cls.fullClassName, isArray, false, constraints(s), toParamType(p), true,</span>
<span class="fc" id="L148">                                    Optional.ofNullable(p.getDescription()), Optional.empty(), Optional.empty());</span>
                        }
<span class="fc" id="L150">                        params.add(param);</span>
<span class="fc" id="L151">                    });</span>
        }
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (operation.getRequestBody() != null) {</span>
<span class="fc" id="L154">            RequestBody b = resolveRefs(operation.getRequestBody());</span>
<span class="fc" id="L155">            MediaType mediaType = mediaType(b.getContent(), &quot;application/json&quot;).map(Entry::getValue).orElse(null);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (mediaType == null) {</span>
<span class="fc" id="L157">                mediaType = mediaType(b.getContent(), &quot;application/xml&quot;).map(Entry::getValue).orElse(null);</span>
            }
            final boolean isMultipartFormData;
<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (mediaType == null) {</span>
<span class="fc" id="L161">                mediaType = mediaType(b.getContent(), &quot;multipart/form-data&quot;).map(Entry::getValue).orElse(null);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">                isMultipartFormData = mediaType != null;</span>
            } else {
<span class="fc" id="L164">                isMultipartFormData = false;</span>
            }
            final boolean isFormUrlEncoded;
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (mediaType == null) {</span>
<span class="fc" id="L168">                mediaType = mediaType(b.getContent(), &quot;application/x-www-form-urlencoded&quot;).map(Entry::getValue).orElse(null);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                isFormUrlEncoded = mediaType != null;</span>
            } else {
<span class="fc" id="L171">                isFormUrlEncoded = false;</span>
            }
<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (mediaType != null) {</span>
<span class="fc" id="L174">                Schema&lt;?&gt; schema = mediaType.getSchema();</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                if (schema != null) {</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                    if (schemaCls.get(schema) != null) {</span>
<span class="fc" id="L177">                        String fullClassName = resolveRefsFullClassName(schema);</span>
                        ParamType paramType;
<span class="fc bfc" id="L179" title="All 2 branches covered.">                        if (isMultipartFormData) {</span>
<span class="fc" id="L180">                            paramType = ParamType.MULTIPART_FORM_DATA;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                        } else if (isFormUrlEncoded){</span>
<span class="fc" id="L182">                            paramType = ParamType.FORM_URLENCODED;</span>
                        } else {
<span class="fc" id="L184">                            paramType = ParamType.BODY;</span>
                        }
<span class="fc" id="L186">                        params.add(new Param(&quot;requestBody&quot;, &quot;requestBody&quot;,</span>
<span class="fc" id="L187">                                Optional.ofNullable((Object) schema.getDefault()),</span>
<span class="fc" id="L188">                                org.davidmoten.oa3.codegen.util.Util.orElse(b.getRequired(), true), fullClassName,</span>
<span class="fc" id="L189">                                false, true, constraints(schema), paramType, false,</span>
<span class="fc" id="L190">                                Optional.ofNullable(schema.getDescription()), Optional.empty(), Optional.empty()));</span>
<span class="fc" id="L191">                    } else {</span>
<span class="nc" id="L192">                        throw new RuntimeException(&quot;unexpected&quot;);</span>
                    }
                } else {
<span class="nc" id="L195">                    addRequestBodyOctetStreamParameter(params, b, Optional.empty());</span>
                }
<span class="fc" id="L197">            } else {</span>
<span class="fc" id="L198">                System.out.println(&quot;TODO handle request body with media types &quot; + b.getContent().keySet());</span>
            }
<span class="fc" id="L200">            consumes = new ArrayList&lt;&gt;(b.getContent().keySet());</span>
        }
<span class="fc" id="L202">        Optional&lt;StatusCodeApiResponse&gt; response = primaryResponse(operation.getResponses());</span>
<span class="fc" id="L203">        Optional&lt;String&gt; primaryStatusCode = response.map(x -&gt; x.statusCode);</span>
<span class="fc" id="L204">        Mutable&lt;String&gt; primaryMimeType = Mutable.create(null);</span>
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        if (response.isPresent() &amp;&amp; response.get().response != null) {</span>
<span class="fc" id="L206">            Content content = resolveResponseRefs(response.get().response).getContent();</span>
            // if content is null then their is no response body
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (content != null) {</span>
<span class="fc" id="L209">                primaryMimeType.value = &quot;application/json&quot;;</span>
<span class="fc" id="L210">                MediaType mediaType = mediaType(content, &quot;application/json&quot;).map(Entry::getValue).orElse(null);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                if (mediaType == null) {</span>
<span class="fc" id="L212">                    primaryMimeType.value = &quot;application/xml&quot;;</span>
<span class="fc" id="L213">                    mediaType = mediaType(content, primaryMimeType.value).map(Entry::getValue).orElse(null);</span>
                }
<span class="fc bfc" id="L215" title="All 2 branches covered.">                if (mediaType != null) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                    if (mediaType.getSchema() == null) {</span>
                        // Any schema
<span class="fc" id="L218">                        returnFullClassName = Optional.of(Object.class.getCanonicalName());</span>
                    } else {
<span class="fc" id="L220">                        returnFullClassName = Optional.of(resolveRefsFullClassName(mediaType.getSchema()));</span>
                    }
                } else {
                    // loop through all mime-types and pick first non-default to infer return class
                    // name
<span class="fc" id="L225">                    final String defaultReturnClassFullName = byte[].class.getCanonicalName();</span>
<span class="fc" id="L226">                    returnFullClassName = content. //</span>
<span class="fc" id="L227">                            keySet() //</span>
<span class="fc" id="L228">                            .stream() //</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                            .filter(x -&gt; !&quot;default&quot;.equals(x)) //</span>
<span class="fc" id="L230">                            .map(x -&gt; {</span>
<span class="fc" id="L231">                                primaryMimeType.value = x;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">                                if (x.startsWith(&quot;text/&quot;)) {</span>
<span class="fc" id="L233">                                    return String.class.getCanonicalName();</span>
                                } else {
<span class="fc" id="L235">                                    return defaultReturnClassFullName;</span>
                                }
                            }) //
<span class="fc" id="L238">                            .findFirst();</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">                    if (!returnFullClassName.isPresent()) {</span>
<span class="nc" id="L240">                        primaryMimeType.value = &quot;default&quot;;</span>
<span class="nc" id="L241">                        MediaType a = content.get(primaryMimeType.value);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                        if (a == null) {</span>
<span class="nc" id="L243">                            returnFullClassName = Optional.empty();</span>
                        } else {
<span class="nc" id="L245">                            returnFullClassName = Optional.of(resolveRefsFullClassName(a.getSchema()));</span>
                        }
                    }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                    if (!returnFullClassName.isPresent()) {</span>
<span class="nc" id="L249">                        primaryMimeType.value = null;</span>
                    }
                }
<span class="fc" id="L252">                statusCode = Optional.of(response.get().statusCode);</span>
<span class="fc" id="L253">                produces = new ArrayList&lt;&gt;(content.keySet());</span>
            }
        }

<span class="fc" id="L257">        List&lt;ResponseDescriptor&gt; responseDescriptors = responseDescriptors(operation);</span>
        boolean includeForServerGeneration;
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (operation.getExtensions() != null) {</span>
<span class="fc" id="L260">            includeForServerGeneration = Boolean.TRUE.equals(</span>
<span class="fc" id="L261">                    operation.getExtensions().getOrDefault(ExtensionKeys.INCLUDE_FOR_SERVER_GENERATION, &quot;&quot;));</span>
        } else {
<span class="fc" id="L263">            includeForServerGeneration = true;</span>
        }
<span class="fc" id="L265">        Method m = new Method(methodName, statusCode, params, returnFullClassName, pathName, method, consumes, produces,</span>
<span class="fc" id="L266">                Optional.ofNullable(operation.getDescription()), primaryStatusCode,</span>
<span class="fc" id="L267">                Optional.ofNullable(primaryMimeType.value), responseDescriptors, includeForServerGeneration);</span>
<span class="fc" id="L268">        methods.add(m);</span>
<span class="fc" id="L269">    }</span>

    private static String operationName(String pathName, HttpMethod method, Operation operation) {
<span class="nc" id="L272">        return pathName + &quot; &quot; + method</span>
<span class="nc" id="L273">                + Optional.ofNullable(operation.getOperationId()).map(x -&gt; &quot; [&quot; + x + &quot;]&quot;).orElse(&quot;&quot;);</span>
    }

    private static ParamType toParamType(Parameter p) {
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (p instanceof QueryParameter) {</span>
<span class="fc" id="L278">            return ParamType.QUERY;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        } else if (p instanceof PathParameter) {</span>
<span class="fc" id="L280">            return ParamType.PATH;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        } else if (p instanceof HeaderParameter) {</span>
<span class="fc" id="L282">            return ParamType.HEADER;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        } else if (p instanceof CookieParameter) {</span>
<span class="fc" id="L284">            return ParamType.COOKIE;</span>
        } else {
<span class="nc" id="L286">            return ParamType.valueOf(p.getIn().toUpperCase(Locale.ENGLISH));</span>
        }
    }

    private void addRequestBodyOctetStreamParameter(List&lt;Param&gt; params, RequestBody b, Optional&lt;String&gt; contentType) {
        // if no schema specified then is octet-stream
<span class="nc" id="L292">        String fullClassName = byte[].class.getCanonicalName();</span>
<span class="nc" id="L293">        params.add(new Param(&quot;requestBody&quot;, &quot;requestBody&quot;, Optional.empty(),</span>
<span class="nc" id="L294">                org.davidmoten.oa3.codegen.util.Util.orElse(b.getRequired(), true), fullClassName, false,</span>
<span class="nc" id="L295">                true, Constraints.empty(), ParamType.BODY, false,</span>
<span class="nc" id="L296">                Optional.empty(), contentType, Optional.empty()));</span>
<span class="nc" id="L297">    }</span>

    private Optional&lt;Entry&lt;String, MediaType&gt;&gt; mediaType(Content content, String mimeType) {
<span class="fc" id="L300">        return content.entrySet() //</span>
<span class="fc" id="L301">                .stream() //</span>
<span class="fc" id="L302">                .filter(x -&gt; x.getKey().replaceAll(&quot;;.*&quot;, &quot;&quot;).equalsIgnoreCase(mimeType))</span>
<span class="fc" id="L303">                .findFirst();</span>
    }

    private List&lt;ResponseDescriptor&gt; responseDescriptors(Operation operation) {
<span class="fc" id="L307">        List&lt;ResponseDescriptor&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L308">        operation.getResponses().forEach((statusCode, response) -&gt; {</span>
<span class="fc" id="L309">            response = resolveResponseRefs(response);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (response.getContent() != null) {</span>
<span class="fc" id="L311">                response.getContent().forEach((contentType, mediaType) -&gt; {</span>
                    final String fullClassName;
<span class="fc bfc" id="L313" title="All 2 branches covered.">                    if (mediaType.getSchema() == null) {</span>
<span class="fc" id="L314">                        fullClassName = byte[].class.getCanonicalName();</span>
                    } else {
<span class="fc" id="L316">                        fullClassName = resolveRefsFullClassName(mediaType.getSchema());</span>
                    }
<span class="fc" id="L318">                    list.add(new ResponseDescriptor(statusCode, contentType, fullClassName));</span>
<span class="fc" id="L319">                });</span>
            }
<span class="fc" id="L321">        });</span>
<span class="fc" id="L322">        return list;</span>
    }

    private RequestBody resolveRefs(RequestBody b) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        while (b.get$ref() != null) {</span>
<span class="fc" id="L327">            b = names.lookupRequestBody(b.get$ref());</span>
        }
<span class="fc" id="L329">        return b;</span>
    }

    private static Constraints constraints(Schema&lt;?&gt; schema) {
<span class="fc" id="L333">        return new Constraints(Optional.ofNullable(schema.getMinLength()), Optional.ofNullable(schema.getMaxLength()),</span>
<span class="fc" id="L334">                Optional.ofNullable(schema.getMinimum()), Optional.ofNullable(schema.getMaximum()),</span>
<span class="fc" id="L335">                Optional.ofNullable(schema.getExclusiveMinimumValue()),</span>
<span class="fc" id="L336">                Optional.ofNullable(schema.getExclusiveMaximumValue()), Optional.ofNullable(schema.getMinItems()),</span>
<span class="fc" id="L337">                Optional.ofNullable(schema.getMaxItems()), Optional.ofNullable(schema.getPattern()));</span>
    }

    private static Optional&lt;StatusCodeApiResponse&gt; primaryResponse(ApiResponses responses) {
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (responses.get(&quot;200&quot;) != null) {</span>
<span class="fc" id="L342">            return Optional.of(new StatusCodeApiResponse(&quot;200&quot;, responses.get(&quot;200&quot;)));</span>
        } else {
<span class="fc bfc" id="L344" title="All 2 branches covered.">            for (Entry&lt;String, ApiResponse&gt; r : responses.entrySet()) {</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                if (is2XX(r.getKey())) {</span>
<span class="fc" id="L346">                    return Optional.of(new StatusCodeApiResponse(r.getKey(), r.getValue()));</span>
                }
<span class="fc" id="L348">            }</span>
        }
<span class="fc" id="L350">        return Optional.empty();</span>
    }

    public static final class StatusCodeApiResponse {
        final String statusCode;
        final ApiResponse response;

<span class="fc" id="L357">        StatusCodeApiResponse(String statusCode, ApiResponse response) {</span>
<span class="fc" id="L358">            this.statusCode = statusCode;</span>
<span class="fc" id="L359">            this.response = response;</span>
<span class="fc" id="L360">        }</span>
        
    }

    private static boolean is2XX(String key) {
<span class="pc bpc" id="L365" title="1 of 4 branches missed.">        return key.length() == 3 &amp;&amp; key.startsWith(&quot;2&quot;);</span>
    }

    private Parameter resolveParameterRefs(Parameter p) {
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        while (p.get$ref() != null) {</span>
<span class="nc" id="L370">            p = names.lookupParameter(p.get$ref());</span>
        }
<span class="fc" id="L372">        return p;</span>
    }

    private ApiResponse resolveResponseRefs(ApiResponse r) {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        while (r.get$ref() != null) {</span>
<span class="fc" id="L377">            String ref = r.get$ref();</span>
<span class="fc" id="L378">            r = names.lookupResponse(ref);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (r == null) {</span>
<span class="nc" id="L380">                throw new RuntimeException(&quot;could not find response &quot; + ref);</span>
            }
<span class="fc" id="L382">        }</span>
<span class="fc" id="L383">        return r;</span>
    }

    private String resolveRefsFullClassName(Schema&lt;?&gt; schema) {
<span class="fc" id="L387">        return schemaCls.get(resolveRefs(schema)).fullClassName;</span>
    }

    private Schema&lt;?&gt; resolveRefs(Schema&lt;?&gt; schema) {
<span class="fc" id="L391">        Schema&lt;?&gt; s = schema;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        while (s.get$ref() != null) {</span>
<span class="fc" id="L393">            String ref = s.get$ref();</span>
<span class="fc" id="L394">            Cls c = refCls.get(ref);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            if (c == null) {</span>
<span class="nc" id="L396">                throw new IllegalArgumentException(&quot;Cls not found for schema=\n&quot; + schema + &quot;\nrefCls map keys=\n&quot; + refCls.keySet());</span>
            }
<span class="fc" id="L398">            s = c.schema.get();</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">            if (s == null) {</span>
<span class="nc" id="L400">                throw new IllegalArgumentException(&quot;$ref not found: &quot; + ref);</span>
            }
<span class="fc" id="L402">        }</span>
<span class="fc" id="L403">        return s;</span>
    }

    public static final class Method {
        public final String methodName;
        public final List&lt;Param&gt; parameters;
        public final Optional&lt;String&gt; returnFullClassName; // arrays always wrapped ?
        public final String path;
        public final HttpMethod httpMethod;
        public final Optional&lt;String&gt; statusCode; // can be 2XX, 3XX, ..
        public final List&lt;String&gt; consumes;
        public final List&lt;String&gt; produces;
        public final Optional&lt;String&gt; description;
        public final Optional&lt;String&gt; primaryStatusCode;
        public final Optional&lt;String&gt; primaryMediaType;
        public final List&lt;ResponseDescriptor&gt; responseDescriptors;
        public final boolean includeForServerGeneration;

        Method(String methodName, Optional&lt;String&gt; statusCode, List&lt;Param&gt; parameters,
                Optional&lt;String&gt; returnFullClassName, String path, HttpMethod httpMethod, List&lt;String&gt; consumes,
                List&lt;String&gt; produces, Optional&lt;String&gt; description, Optional&lt;String&gt; primaryStatusCode,
<span class="fc" id="L424">                Optional&lt;String&gt; primaryMediaType, List&lt;ResponseDescriptor&gt; responseDescriptors, boolean ignoreForServerGeneration) {</span>
<span class="fc" id="L425">            this.methodName = methodName;</span>
<span class="fc" id="L426">            this.statusCode = statusCode;</span>
<span class="fc" id="L427">            this.parameters = parameters;</span>
<span class="fc" id="L428">            this.returnFullClassName = returnFullClassName;</span>
<span class="fc" id="L429">            this.path = path;</span>
<span class="fc" id="L430">            this.httpMethod = httpMethod;</span>
<span class="fc" id="L431">            this.consumes = consumes;</span>
<span class="fc" id="L432">            this.produces = produces;</span>
<span class="fc" id="L433">            this.description = description;</span>
<span class="fc" id="L434">            this.primaryStatusCode = primaryStatusCode;</span>
<span class="fc" id="L435">            this.primaryMediaType = primaryMediaType;</span>
<span class="fc" id="L436">            this.responseDescriptors = responseDescriptors;</span>
<span class="fc" id="L437">            this.includeForServerGeneration = ignoreForServerGeneration;</span>
<span class="fc" id="L438">        }</span>

        public Optional&lt;Integer&gt; statusCodeFirstInRange() {
<span class="fc" id="L441">            return statusCode //</span>
<span class="fc" id="L442">                    .map(x -&gt; x.toUpperCase(Locale.ENGLISH)) //</span>
<span class="fc" id="L443">                    .map(x -&gt; {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">                        if (x.endsWith(&quot;XX&quot;)) {</span>
<span class="fc" id="L445">                            return Integer.parseInt(x.substring(0, 1)) * 100;</span>
                        } else {
<span class="fc" id="L447">                            return Integer.parseInt(x);</span>
                        }
                    });
        }
        
        @Override
        public String toString() {
<span class="nc" id="L454">            return &quot;Method [path=&quot; + path + &quot;, httpMethod=&quot; + httpMethod + &quot;, methodName=&quot; + methodName + &quot;, returnCls=&quot;</span>
<span class="nc" id="L455">                    + returnFullClassName.orElse(&quot;&quot;) + &quot;, parameters=&quot;</span>
<span class="nc" id="L456">                    + parameters.stream().map(Object::toString).map(x -&gt; &quot;\n    &quot; + x).collect(Collectors.joining())</span>
                    + &quot;, ignoreForServerGeneration=&quot; + includeForServerGeneration;
        }

    }

    public static final class ResponseDescriptor {
        private final String statusCode; // can be a pattern like `2*`
        private final String mediaType;
        private final String fullClassName;

<span class="fc" id="L467">        public ResponseDescriptor(String statusCode, String mediaType, String fullClassName) {</span>
<span class="fc" id="L468">            this.statusCode = statusCode;</span>
<span class="fc" id="L469">            this.mediaType = mediaType;</span>
<span class="fc" id="L470">            this.fullClassName = fullClassName;</span>
<span class="fc" id="L471">        }</span>

        public String statusCode() {
<span class="fc" id="L474">            return statusCode;</span>
        }

        public String mediaType() {
<span class="fc" id="L478">            return mediaType;</span>
        }

        public String fullClassName() {
<span class="fc" id="L482">            return fullClassName;</span>
        }

    }

    public static final class Constraints {
        public final Optional&lt;Integer&gt; minLength;
        public final Optional&lt;Integer&gt; maxLength;
        public final Optional&lt;BigDecimal&gt; min;
        public final Optional&lt;BigDecimal&gt; max;
        public final Optional&lt;BigDecimal&gt; minExclusive;
        public final Optional&lt;BigDecimal&gt; maxExclusive;
        public final Optional&lt;Integer&gt; minItems;
        public final Optional&lt;Integer&gt; maxItems;
        public final Optional&lt;String&gt; pattern;

        public Constraints(Optional&lt;Integer&gt; minLength, Optional&lt;Integer&gt; maxLength, Optional&lt;BigDecimal&gt; min,
                Optional&lt;BigDecimal&gt; max, Optional&lt;BigDecimal&gt; minExclusive, Optional&lt;BigDecimal&gt; maxExclusive,
<span class="fc" id="L500">                Optional&lt;Integer&gt; minItems, Optional&lt;Integer&gt; maxItems, Optional&lt;String&gt; pattern) {</span>
<span class="fc" id="L501">            this.minLength = minLength;</span>
<span class="fc" id="L502">            this.maxLength = maxLength;</span>
<span class="fc" id="L503">            this.min = min;</span>
<span class="fc" id="L504">            this.max = max;</span>
<span class="fc" id="L505">            this.minExclusive = minExclusive;</span>
<span class="fc" id="L506">            this.maxExclusive = maxExclusive;</span>
<span class="fc" id="L507">            this.minItems = minItems;</span>
<span class="fc" id="L508">            this.maxItems = maxItems;</span>
<span class="fc" id="L509">            this.pattern = pattern;</span>
<span class="fc" id="L510">        }</span>

        public static Constraints empty() {
<span class="nc" id="L513">            return new Constraints(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),</span>
<span class="nc" id="L514">                    Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());</span>
        }

        public boolean atLeastOnePresent() {
<span class="pc bpc" id="L518" title="1 of 8 branches missed.">            return minLength.isPresent() || maxLength.isPresent() || min.isPresent() || max.isPresent()</span>
<span class="pc bpc" id="L519" title="3 of 6 branches missed.">                    || minExclusive.isPresent() || maxExclusive.isPresent() || minItems.isPresent()</span>
<span class="pc bpc" id="L520" title="2 of 4 branches missed.">                    || maxItems.isPresent() || pattern.isPresent();</span>
        }

    }

    public static final class Param {
        public final String name;
        public final String identifier;
        public final Optional&lt;Object&gt; defaultValue;
        public final boolean required;
        public final String fullClassName;
        public final boolean isArray;
        public final boolean isRequestBody;
        public final Constraints constraints;
        public final ParamType type;
        public final boolean isComplexQueryParameter;
        public final Optional&lt;String&gt; description;
        public final Optional&lt;String&gt; contentType;
        public final Optional&lt;String&gt; filename;

        public Param(String name, String identifier, Optional&lt;Object&gt; defaultValue, boolean required,
                String fullClassName, boolean isArray, boolean isRequestBody, Constraints constraints, ParamType type,
<span class="fc" id="L542">                boolean isComplexQueryParameter, Optional&lt;String&gt; description, Optional&lt;String&gt; contentType, Optional&lt;String&gt; filename) {</span>
<span class="fc" id="L543">            this.name = name;</span>
<span class="fc" id="L544">            this.identifier = identifier;</span>
<span class="fc" id="L545">            this.defaultValue = defaultValue;</span>
<span class="fc" id="L546">            this.required = required;</span>
<span class="fc" id="L547">            this.fullClassName = fullClassName;</span>
<span class="fc" id="L548">            this.isArray = isArray;</span>
<span class="fc" id="L549">            this.isRequestBody = isRequestBody;</span>
<span class="fc" id="L550">            this.constraints = constraints;</span>
<span class="fc" id="L551">            this.type = type;</span>
<span class="fc" id="L552">            this.isComplexQueryParameter = isComplexQueryParameter;</span>
<span class="fc" id="L553">            this.description = description;</span>
<span class="fc" id="L554">            this.contentType = contentType;</span>
<span class="fc" id="L555">            this.filename = filename;</span>
<span class="fc" id="L556">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L560">            return &quot;Param [&quot; + identifier + &quot;, name=&quot; + name + &quot;, defaultValue=&quot; + defaultValue.orElse(&quot;&quot;) + &quot;, required=&quot;</span>
                    + required + &quot;, cls=&quot; + fullClassName + &quot;, isArray=&quot; + isArray + &quot;, contentType=&quot;
<span class="nc" id="L562">                    + contentType.orElse(&quot;&quot;) + &quot;, filename=&quot; + filename.orElse(&quot;&quot;) + &quot;, desc='&quot; + description.orElse(&quot;&quot;) + &quot;']&quot;;</span>
                            
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>