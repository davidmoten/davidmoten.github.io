<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlElement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">aws-lightweight-client-java</a> &gt; <a href="index.source.html" class="el_package">com.github.davidmoten.aws.lw.client.xml</a> &gt; <span class="el_source">XmlElement.java</span></div><h1>XmlElement.java</h1><pre class="source lang-java linenums">/* XMLElement.java
 *
 * $Revision: 1.4 $
 * $Date: 2002/03/24 10:27:59 $
 * $Name: RELEASE_2_2_1 $
 *
 * This file is part of NanoXML 2 Lite.
 * Copyright (C) 2000-2002 Marc De Scheemaecker, All Rights Reserved.
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from the
 * use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *  1. The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software in
 *     a product, an acknowledgment in the product documentation would be
 *     appreciated but is not required.
 *
 *  2. Altered source versions must be plainly marked as such, and must not be
 *     misrepresented as being the original software.
 *
 *  3. This notice may not be removed or altered from any source distribution.
 *****************************************************************************/

// ALTERED greatly by Dave Moten May 2021

package com.github.davidmoten.aws.lw.client.xml;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.stream.Collectors;

import com.github.davidmoten.aws.lw.client.internal.util.Preconditions;

/* 
 * The NanoXML 2 Lite licence blurb is included here. The class has been 
 * completely butchered but the core xml parsing routines are thanks to 
 * the NanoXML authors.
 *  
 **/

/* XmlElement.java
*
* $Revision: 1.4 $
* $Date: 2002/03/24 10:27:59 $
* $Name: RELEASE_2_2_1 $
*
* This file is part of NanoXML 2 Lite.
* Copyright (C) 2000-2002 Marc De Scheemaecker, All Rights Reserved.
*
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
*  1. The origin of this software must not be misrepresented; you must not
*     claim that you wrote the original software. If you use this software in
*     a product, an acknowledgment in the product documentation would be
*     appreciated but is not required.
*
*  2. Altered source versions must be plainly marked as such, and must not be
*     misrepresented as being the original software.
*
*  3. This notice may not be removed or altered from any source distribution.
*****************************************************************************/

public final class XmlElement {

    private List&lt;XmlElement&gt; children;
    private Map&lt;String, String&gt; attributes;
    private String name;

    /**
     * The #PCDATA content of the object. null if no #PCDATA, can be empty string
     */
    private String content; // non-null

<span class="fc" id="L99">    private static final Map&lt;String, char[]&gt; ENTITIES = createEntities();</span>

    /**
     * The line number where the element starts.
     *
     */
    private int lineNr;

    /**
     * &lt;code&gt;true&lt;/code&gt; if the leading and trailing whitespace of #PCDATA sections
     * have to be ignored.
     */
    private final boolean ignoreLeadingAndTrailingWhitespace;

    /**
     * Character read too much. This character provides push-back functionality to
     * the input reader without having to use a PushbackReader. If there is no such
     * character, this field is '\0'.
     */
    private char charReadTooMuch;

    /**
     * The reader provided by the caller of the parse method.
     */
    private Reader reader;

    /**
     * The current line number in the source content.
     */
    private int parserLineNr;

<span class="fc" id="L130">    private XmlElement(boolean ignoreLeadingAndTrailingWhitespace) {</span>
<span class="fc" id="L131">        this.ignoreLeadingAndTrailingWhitespace = ignoreLeadingAndTrailingWhitespace;</span>
<span class="fc" id="L132">        this.name = null;</span>
<span class="fc" id="L133">        this.content = &quot;&quot;;</span>
<span class="fc" id="L134">        this.attributes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L135">        this.children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L136">        this.lineNr = 0;</span>
<span class="fc" id="L137">    }</span>

    public void addChild(XmlElement child) {
<span class="fc" id="L140">        children.add(child);</span>
<span class="fc" id="L141">    }</span>

    public int countChildren() {
<span class="fc" id="L144">        return children.size();</span>
    }

    public boolean hasChildren() {
<span class="fc bfc" id="L148" title="All 2 branches covered.">        return !children.isEmpty();</span>
    }

    public Set&lt;String&gt; attributeNames() {
<span class="fc" id="L152">        return attributes.keySet();</span>
    }

    public List&lt;XmlElement&gt; children() {
<span class="fc" id="L156">        return children;</span>
    }

    public List&lt;XmlElement&gt; childrenWithName(String name) {
<span class="fc" id="L160">        return children.stream().filter(x -&gt; name.equals(x.name())).collect(Collectors.toList());</span>
    }

    public XmlElement firstChild() {
<span class="fc" id="L164">        return children.get(0);</span>
    }

    public XmlElement child(int index) {
<span class="fc" id="L168">        return children.get(index);</span>
    }

    public XmlElement child(String... names) {
<span class="fc" id="L172">        XmlElement x = this;</span>
<span class="fc" id="L173">        XmlElement y = null;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (String name : names) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (XmlElement child : x.children) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                if (child.name().equals(name)) {</span>
<span class="fc" id="L177">                    y = child;</span>
                }
<span class="fc" id="L179">            }</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (y == null) {</span>
<span class="fc" id="L181">                throw new NoSuchElementException(&quot;child not found with name: &quot; + name);</span>
            } else {
<span class="fc" id="L183">                x = y;</span>
            }
        }
<span class="fc" id="L186">        return y;</span>
    }

    public String content(String... names) {
<span class="fc" id="L190">        return child(names).content();</span>
    }

    /**
     * Returns the PCDATA content of the object. If there is no such content,
     * &lt;CODE&gt;null&lt;/CODE&gt; is returned.
     */
    public String content() {
<span class="fc" id="L198">        return this.content;</span>
    }

    /**
     * Returns the line nr in the source data on which the element is found. This
     * method returns &lt;code&gt;0&lt;/code&gt; there is no associated source data.
     */
    public int lineNumber() {
<span class="fc" id="L206">        return this.lineNr;</span>
    }

    /**
     * Returns an attribute of the element. If the attribute doesn't exist,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * @param name The name of the attribute.
     */
    public String attribute(String name) {
<span class="fc" id="L216">        return this.attribute(name, null);</span>
    }

    /**
     * Returns an attribute of the element. If the attribute doesn't exist,
     * &lt;code&gt;defaultValue&lt;/code&gt; is returned.
     *
     * @param name         The name of the attribute.
     * @param defaultValue Key to use if the attribute is missing.
     */
    public String attribute(String name, String defaultValue) {
<span class="fc" id="L227">        Preconditions.checkNotNull(name);</span>
<span class="fc" id="L228">        return this.attributes.getOrDefault(name, defaultValue);</span>
    }

    /**
     * Returns the name of the element.
     */
    public String name() {
<span class="fc" id="L235">        return this.name;</span>
    }

    public static XmlElement parse(Reader reader) throws XmlParseException, IOException {
<span class="fc" id="L239">        return parse(reader, true);</span>
    }

    public static XmlElement parse(Reader reader, boolean ignoreLeadingAndTrailingWhitespace)
            throws IOException, XmlParseException {
<span class="fc" id="L244">        Preconditions.checkNotNull(reader);</span>
<span class="fc" id="L245">        XmlElement x = new XmlElement(ignoreLeadingAndTrailingWhitespace);</span>
<span class="fc" id="L246">        x.parseFromReader(reader);</span>
<span class="fc" id="L247">        return x;</span>
    }

    private void parseFromReader(Reader reader) throws IOException, XmlParseException {
<span class="fc" id="L251">        Preconditions.checkNotNull(reader);</span>
<span class="fc" id="L252">        this.name = null;</span>
<span class="fc" id="L253">        this.content = &quot;&quot;;</span>
<span class="fc" id="L254">        this.attributes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L255">        this.children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L256">        this.charReadTooMuch = '\0';</span>
<span class="fc" id="L257">        this.reader = reader;</span>
<span class="fc" id="L258">        this.parserLineNr = 1;</span>

        for (;;) {
<span class="fc" id="L261">            char ch = this.scanWhitespace();</span>

<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (ch != '&lt;') {</span>
<span class="fc" id="L264">                throw this.createUnexpectedInputException(&quot;&lt;&quot;);</span>
            }

<span class="fc" id="L267">            ch = this.readChar();</span>

<span class="fc bfc" id="L269" title="All 4 branches covered.">            if ((ch == '!') || (ch == '?')) {</span>
<span class="fc" id="L270">                this.skipSpecialTag(0);</span>
            } else {
<span class="fc" id="L272">                this.unreadChar(ch);</span>
<span class="fc" id="L273">                this.scanElement(this);</span>
<span class="fc" id="L274">                return;</span>
            }
<span class="fc" id="L276">        }</span>
    }

    public static XmlElement parse(String string) throws XmlParseException {
<span class="fc" id="L280">        return parse(string, true);</span>
    }

    public static XmlElement parse(String string, boolean ignoreLeadingAndTrailingWhitespace)
            throws XmlParseException {
<span class="fc" id="L285">        Preconditions.checkNotNull(string);</span>
<span class="fc" id="L286">        return parseUnchecked(new StringReader(string), ignoreLeadingAndTrailingWhitespace);</span>
    }

    // VisibleForTesting
    static XmlElement parseUnchecked(Reader reader, boolean ignoreLeadingAndTrailingWhitespace)
            throws XmlParseException {
        try {
<span class="fc" id="L293">            return parse(reader, ignoreLeadingAndTrailingWhitespace);</span>
<span class="fc" id="L294">        } catch (IOException e) {</span>
<span class="fc" id="L295">            throw new UncheckedIOException(e);</span>
        }
    }

    private XmlElement createAnotherElement() {
<span class="fc" id="L300">        return new XmlElement(this.ignoreLeadingAndTrailingWhitespace);</span>
    }

    public String toString() {
<span class="fc" id="L304">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L305">        OutputStreamWriter writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);</span>
<span class="fc" id="L306">        writeUnchecked(writer);</span>
<span class="fc" id="L307">        return new String(out.toByteArray(), StandardCharsets.UTF_8);</span>
    }

    // visible for testing
    void writeUnchecked(Writer writer) {
        try {
<span class="fc" id="L313">            this.write(writer);</span>
<span class="fc" id="L314">        } catch (IOException e) {</span>
<span class="fc" id="L315">            throw new UncheckedIOException(e);</span>
        } finally {
            try {
<span class="fc" id="L318">                writer.close();</span>
<span class="fc" id="L319">            } catch (IOException e) {</span>
<span class="fc" id="L320">                throw new UncheckedIOException(e);</span>
<span class="fc" id="L321">            }</span>
        }
<span class="fc" id="L323">    }</span>

    public void write(Writer writer) throws IOException {
<span class="fc" id="L326">        Preconditions.checkNotNull(writer);</span>
<span class="fc" id="L327">        Preconditions.checkNotNull(name);</span>
<span class="fc" id="L328">        Preconditions.checkNotNull(content);</span>
//        if (this.name == null) {
//            writeEncoded(writer, this.content);
//            return;
//        }
<span class="fc" id="L333">        writer.write('&lt;');</span>
<span class="fc" id="L334">        writer.write(this.name);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (!this.attributes.isEmpty()) {</span>
<span class="fc" id="L336">            Enumeration&lt;String&gt; en = Collections.enumeration(this.attributes.keySet());</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            while (en.hasMoreElements()) {</span>
<span class="fc" id="L338">                writer.write(' ');</span>
<span class="fc" id="L339">                String key = (String) en.nextElement();</span>
<span class="fc" id="L340">                String value = (String) this.attributes.get(key);</span>
<span class="fc" id="L341">                writer.write(key);</span>
<span class="fc" id="L342">                writer.write('=');</span>
<span class="fc" id="L343">                writer.write('&quot;');</span>
<span class="fc" id="L344">                writeEncoded(writer, value);</span>
<span class="fc" id="L345">                writer.write('&quot;');</span>
<span class="fc" id="L346">            }</span>
        }
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (!content.isEmpty()) {</span>
<span class="fc" id="L349">            writer.write('&gt;');</span>
<span class="fc" id="L350">            writeEncoded(writer, this.content);</span>
<span class="fc" id="L351">            writer.write('&lt;');</span>
<span class="fc" id="L352">            writer.write('/');</span>
<span class="fc" id="L353">            writer.write(this.name);</span>
<span class="fc" id="L354">            writer.write('&gt;');</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        } else if (children.isEmpty()) {</span>
<span class="fc" id="L356">            writer.write('/');</span>
<span class="fc" id="L357">            writer.write('&gt;');</span>
        } else {
<span class="fc" id="L359">            writer.write('&gt;');</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            for (XmlElement child : children) {</span>
<span class="fc" id="L361">                child.write(writer);</span>
<span class="fc" id="L362">            }</span>
<span class="fc" id="L363">            writer.write('&lt;');</span>
<span class="fc" id="L364">            writer.write('/');</span>
<span class="fc" id="L365">            writer.write(this.name);</span>
<span class="fc" id="L366">            writer.write('&gt;');</span>
        }
<span class="fc" id="L368">    }</span>

    private static void writeEncoded(Writer writer, String str) throws IOException {
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (int i = 0; i &lt; str.length(); i += 1) {</span>
<span class="fc" id="L372">            char ch = str.charAt(i);</span>
<span class="fc bfc" id="L373" title="All 6 branches covered.">            switch (ch) {</span>
            case '&lt;':
<span class="fc" id="L375">                writer.write('&amp;');</span>
<span class="fc" id="L376">                writer.write('l');</span>
<span class="fc" id="L377">                writer.write('t');</span>
<span class="fc" id="L378">                writer.write(';');</span>
<span class="fc" id="L379">                break;</span>
            case '&gt;':
<span class="fc" id="L381">                writer.write('&amp;');</span>
<span class="fc" id="L382">                writer.write('g');</span>
<span class="fc" id="L383">                writer.write('t');</span>
<span class="fc" id="L384">                writer.write(';');</span>
<span class="fc" id="L385">                break;</span>
            case '&amp;':
<span class="fc" id="L387">                writer.write('&amp;');</span>
<span class="fc" id="L388">                writer.write('a');</span>
<span class="fc" id="L389">                writer.write('m');</span>
<span class="fc" id="L390">                writer.write('p');</span>
<span class="fc" id="L391">                writer.write(';');</span>
<span class="fc" id="L392">                break;</span>
            case '&quot;':
<span class="fc" id="L394">                writer.write('&amp;');</span>
<span class="fc" id="L395">                writer.write('q');</span>
<span class="fc" id="L396">                writer.write('u');</span>
<span class="fc" id="L397">                writer.write('o');</span>
<span class="fc" id="L398">                writer.write('t');</span>
<span class="fc" id="L399">                writer.write(';');</span>
<span class="fc" id="L400">                break;</span>
            case '\'':
<span class="fc" id="L402">                writer.write('&amp;');</span>
<span class="fc" id="L403">                writer.write('a');</span>
<span class="fc" id="L404">                writer.write('p');</span>
<span class="fc" id="L405">                writer.write('o');</span>
<span class="fc" id="L406">                writer.write('s');</span>
<span class="fc" id="L407">                writer.write(';');</span>
<span class="fc" id="L408">                break;</span>
            default:
<span class="fc" id="L410">                int unicode = (int) ch;</span>
<span class="fc bfc" id="L411" title="All 4 branches covered.">                if ((unicode &lt; 32) || (unicode &gt; 126)) {</span>
<span class="fc" id="L412">                    writer.write('&amp;');</span>
<span class="fc" id="L413">                    writer.write('#');</span>
<span class="fc" id="L414">                    writer.write('x');</span>
<span class="fc" id="L415">                    writer.write(Integer.toString(unicode, 16));</span>
<span class="fc" id="L416">                    writer.write(';');</span>
                } else {
<span class="fc" id="L418">                    writer.write(ch);</span>
                }
            }
        }
<span class="fc" id="L422">    }</span>

    /**
     * Scans an identifier from the current reader. The scanned identifier is
     * appended to &lt;code&gt;result&lt;/code&gt;.
     *
     * @param result The buffer in which the scanned identifier will be put.
     */
    private void scanIdentifier(StringBuilder result) throws IOException {
        for (;;) {
<span class="fc" id="L432">            char ch = this.readChar();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (!isValidIdentifierCharacter(ch)) {</span>
<span class="fc" id="L434">                this.unreadChar(ch);</span>
<span class="fc" id="L435">                return;</span>
            }
<span class="fc" id="L437">            result.append(ch);</span>
<span class="fc" id="L438">        }</span>
    }

    // VisibleForTesting
    static boolean isValidIdentifierCharacter(char ch) {
<span class="fc bfc" id="L443" title="All 22 branches covered.">        return ((ch &gt;= 'A') &amp;&amp; (ch &lt;= 'Z')) || //</span>
                ((ch &gt;= 'a') &amp;&amp; (ch &lt;= 'z')) || //
                ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')) || //
                (ch == '_') || //
                (ch == '.') || //
                (ch == ':') || //
                (ch == '-') || //
                (ch &gt; '\u007E');
    }

    /**
     * This method scans an identifier from the current reader.
     *
     * @return the next character following the whitespace.
     */
    private char scanWhitespace() throws IOException {
        for (;;) {
<span class="fc" id="L460">            char ch = this.readChar();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            switch (ch) {</span>
            case ' ':
            case '\t':
            case '\n':
            case '\r':
<span class="fc" id="L466">                break;</span>
            default:
<span class="fc" id="L468">                return ch;</span>
            }
<span class="fc" id="L470">        }</span>
    }

    /**
     * This method scans an identifier from the current reader. The scanned
     * whitespace is appended to &lt;code&gt;result&lt;/code&gt;.
     *
     * @return the next character following the whitespace.
     */
    private char scanWhitespace(StringBuilder result) throws IOException {
        for (;;) {
<span class="fc" id="L481">            char ch = this.readChar();</span>
<span class="fc bfc" id="L482" title="All 3 branches covered.">            switch (ch) {</span>
            case ' ':
            case '\t':
            case '\n':
<span class="fc" id="L486">                result.append(ch);</span>
            case '\r':
<span class="fc" id="L488">                break;</span>
            default:
<span class="fc" id="L490">                return ch;</span>
            }
<span class="fc" id="L492">        }</span>
    }

    /**
     * This method scans a delimited string from the current reader. The scanned
     * string without delimiters is appended to &lt;code&gt;string&lt;/code&gt;.
     */
    private void scanString(StringBuilder string) throws IOException {
<span class="fc" id="L500">        char delimiter = this.readChar();</span>
<span class="fc bfc" id="L501" title="All 4 branches covered.">        if ((delimiter != '\'') &amp;&amp; (delimiter != '&quot;')) {</span>
<span class="fc" id="L502">            throw this.createUnexpectedInputException(&quot;' or \&quot;&quot;);</span>
        }
        for (;;) {
<span class="fc" id="L505">            char ch = this.readChar();</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">            if (ch == delimiter) {</span>
<span class="fc" id="L507">                return;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            } else if (ch == '&amp;') {</span>
<span class="fc" id="L509">                this.resolveEntity(string);</span>
            } else {
<span class="fc" id="L511">                string.append(ch);</span>
            }
<span class="fc" id="L513">        }</span>
    }

    /**
     * Scans a #PCDATA element. CDATA sections and entities are resolved. The next
     * &amp;lt; char is skipped. The scanned data is appended to &lt;code&gt;data&lt;/code&gt;.
     */
    private void scanPCData(StringBuilder data) throws IOException {
        for (;;) {
<span class="fc" id="L522">            char ch = this.readChar();</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (ch == '&lt;') {</span>

//              System.out.println(&quot;ch=&quot;+ ch + &quot;, rest=&quot;+ readAll());
//              if (true) throw new RuntimeException();
<span class="fc" id="L527">                ch = this.readChar();</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                if (ch == '!') {</span>
<span class="fc" id="L529">                    this.checkCDATA(data);</span>
                } else {
<span class="fc" id="L531">                    this.unreadChar(ch);</span>
<span class="fc" id="L532">                    return;</span>
                }
<span class="fc bfc" id="L534" title="All 2 branches covered.">            } else if (ch == '&amp;') {</span>
<span class="fc" id="L535">                this.resolveEntity(data);</span>
            } else {
<span class="fc" id="L537">                data.append(ch);</span>
            }
<span class="fc" id="L539">        }</span>
    }

    /**
     * Scans a special tag and if the tag is a CDATA section, append its content to
     * &lt;code&gt;buf&lt;/code&gt;.
     */
    private boolean checkCDATA(StringBuilder buf) throws IOException {
<span class="fc" id="L547">        char ch = this.readChar();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (ch != '[') {</span>
<span class="fc" id="L549">            this.unreadChar(ch);</span>
<span class="fc" id="L550">            this.skipSpecialTag(0);</span>
<span class="fc" id="L551">            return false;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        } else if (!this.checkLiteral(&quot;CDATA[&quot;)) {</span>
<span class="fc" id="L553">            this.skipSpecialTag(1); // one [ has already been read</span>
<span class="fc" id="L554">            return false;</span>
        } else {
<span class="fc" id="L556">            int delimiterCharsSkipped = 0;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            while (delimiterCharsSkipped &lt; 3) {</span>
<span class="fc" id="L558">                ch = this.readChar();</span>
<span class="fc bfc" id="L559" title="All 3 branches covered.">                switch (ch) {</span>
                case ']':
<span class="fc bfc" id="L561" title="All 2 branches covered.">                    if (delimiterCharsSkipped &lt; 2) {</span>
<span class="fc" id="L562">                        delimiterCharsSkipped += 1;</span>
                    } else {
<span class="fc" id="L564">                        buf.append(']');</span>
<span class="fc" id="L565">                        buf.append(']');</span>
<span class="fc" id="L566">                        delimiterCharsSkipped = 0;</span>
                    }
<span class="fc" id="L568">                    break;</span>
                case '&gt;':
<span class="fc bfc" id="L570" title="All 2 branches covered.">                    if (delimiterCharsSkipped &lt; 2) {</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                        for (int i = 0; i &lt; delimiterCharsSkipped; i++) {</span>
<span class="fc" id="L572">                            buf.append(']');</span>
                        }
<span class="fc" id="L574">                        delimiterCharsSkipped = 0;</span>
<span class="fc" id="L575">                        buf.append('&gt;');</span>
                    } else {
<span class="fc" id="L577">                        delimiterCharsSkipped = 3;</span>
                    }
<span class="fc" id="L579">                    break;</span>
                default:
<span class="fc bfc" id="L581" title="All 2 branches covered.">                    for (int i = 0; i &lt; delimiterCharsSkipped; i += 1) {</span>
<span class="fc" id="L582">                        buf.append(']');</span>
                    }
<span class="fc" id="L584">                    buf.append(ch);</span>
<span class="fc" id="L585">                    delimiterCharsSkipped = 0;</span>
                }
            }
<span class="fc" id="L588">            return true;</span>
        }
    }

    /**
     * Skips a comment.
     */
    private void skipComment() throws IOException {
<span class="fc" id="L596">        int dashesToRead = 2;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        while (dashesToRead &gt; 0) {</span>
<span class="fc" id="L598">            char ch = this.readChar();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">            if (ch == '-') {</span>
<span class="fc" id="L600">                dashesToRead -= 1;</span>
            } else {
<span class="fc" id="L602">                dashesToRead = 2;</span>
            }
<span class="fc" id="L604">        }</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (this.readChar() != '&gt;') {</span>
<span class="fc" id="L606">            throw this.createUnexpectedInputException(&quot;&gt;&quot;);</span>
        }
<span class="fc" id="L608">    }</span>

    /**
     * Skips a special tag or comment.
     *
     * @param bracketLevel The number of open square brackets ([) that have already
     *                     been read.
     */
    private void skipSpecialTag(int bracketLevel) throws IOException {
<span class="fc" id="L617">        int tagLevel = 1; // &lt;</span>
<span class="fc" id="L618">        char stringDelimiter = '\0';</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">        if (bracketLevel == 0) {</span>
<span class="fc" id="L620">            char ch = this.readChar();</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (ch == '[') {</span>
<span class="fc" id="L622">                bracketLevel += 1;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">            } else if (ch == '-') {</span>
<span class="fc" id="L624">                ch = this.readChar();</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                if (ch == '[') {</span>
<span class="fc" id="L626">                    bracketLevel += 1;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">                } else if (ch == ']') {</span>
<span class="fc" id="L628">                    bracketLevel -= 1;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">                } else if (ch == '-') {</span>
<span class="fc" id="L630">                    this.skipComment();</span>
<span class="fc" id="L631">                    return;</span>
                }
            }
        }
<span class="fc bfc" id="L635" title="All 2 branches covered.">        while (tagLevel &gt; 0) {</span>
<span class="fc" id="L636">            char ch = this.readChar();</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (stringDelimiter == '\0') {</span>
<span class="fc bfc" id="L638" title="All 4 branches covered.">                if ((ch == '&quot;') || (ch == '\'')) {</span>
<span class="fc" id="L639">                    stringDelimiter = ch;</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                } else if (bracketLevel &lt;= 0) {</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                    if (ch == '&lt;') {</span>
<span class="fc" id="L642">                        tagLevel += 1;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                    } else if (ch == '&gt;') {</span>
<span class="fc" id="L644">                        tagLevel -= 1;</span>
                    }
                }
<span class="fc bfc" id="L647" title="All 2 branches covered.">                if (ch == '[') {</span>
<span class="fc" id="L648">                    bracketLevel += 1;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                } else if (ch == ']') {</span>
<span class="fc" id="L650">                    bracketLevel -= 1;</span>
                }
            } else {
<span class="fc bfc" id="L653" title="All 2 branches covered.">                if (ch == stringDelimiter) {</span>
<span class="fc" id="L654">                    stringDelimiter = '\0';</span>
                }
            }
<span class="fc" id="L657">        }</span>
<span class="fc" id="L658">    }</span>

    /**
     * Scans the data for literal text. Scanning stops when a character does not
     * match or after the complete text has been checked, whichever comes first.
     *
     * @param literal the literal to check.
     */
    private boolean checkLiteral(String literal) throws IOException {
<span class="fc" id="L667">        int length = literal.length();</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i += 1) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">            if (this.readChar() != literal.charAt(i)) {</span>
<span class="fc" id="L670">                return false;</span>
            }
        }
<span class="fc" id="L673">        return true;</span>
    }

    /**
     * Reads a character from a reader.
     */
    private char readChar() throws IOException {
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (this.charReadTooMuch != '\0') {</span>
<span class="fc" id="L681">            char ch = this.charReadTooMuch;</span>
<span class="fc" id="L682">            this.charReadTooMuch = '\0';</span>
<span class="fc" id="L683">            return ch;</span>
        } else {
<span class="fc" id="L685">            int i = this.reader.read();</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">            if (i &lt; 0) {</span>
<span class="fc" id="L687">                throw this.createExceptionUnexpectedEndOfData();</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">            } else if (i == 10) {</span>
<span class="fc" id="L689">                this.parserLineNr += 1;</span>
<span class="fc" id="L690">                return '\n';</span>
            } else {
<span class="fc" id="L692">                return (char) i;</span>
            }
        }
    }

    private void scanElement(XmlElement elt) throws IOException {
<span class="fc" id="L698">        StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L699">        this.scanIdentifier(buf);</span>
<span class="fc" id="L700">        String name = buf.toString();</span>
<span class="fc" id="L701">        elt.name = name;</span>
<span class="fc" id="L702">        char ch = this.scanWhitespace();</span>
<span class="fc bfc" id="L703" title="All 4 branches covered.">        while ((ch != '&gt;') &amp;&amp; (ch != '/')) {</span>
<span class="fc" id="L704">            buf.setLength(0);</span>
<span class="fc" id="L705">            this.unreadChar(ch);</span>
<span class="fc" id="L706">            this.scanIdentifier(buf);</span>
<span class="fc" id="L707">            String key = buf.toString();</span>
<span class="fc" id="L708">            ch = this.scanWhitespace();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (ch != '=') {</span>
<span class="fc" id="L710">                throw this.createUnexpectedInputException(&quot;=&quot;);</span>
            }
<span class="fc" id="L712">            this.unreadChar(this.scanWhitespace());</span>
<span class="fc" id="L713">            buf.setLength(0);</span>
<span class="fc" id="L714">            this.scanString(buf);</span>
<span class="fc" id="L715">            elt.attributes.put(key, buf.toString());</span>
<span class="fc" id="L716">            ch = this.scanWhitespace();</span>
<span class="fc" id="L717">        }</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (ch == '/') {</span>
<span class="fc" id="L719">            ch = this.readChar();</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">            if (ch != '&gt;') {</span>
<span class="fc" id="L721">                throw this.createUnexpectedInputException(&quot;&gt;&quot;);</span>
            }
<span class="fc" id="L723">            return;</span>
        }
<span class="fc" id="L725">        buf.setLength(0);</span>
<span class="fc" id="L726">        ch = this.scanWhitespace(buf);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">        if (ch != '&lt;') {</span>
<span class="fc" id="L728">            this.unreadChar(ch);</span>
<span class="fc" id="L729">            this.scanPCData(buf);</span>
        } else {
            for (;;) {
<span class="fc" id="L732">                ch = this.readChar();</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">                if (ch == '!') {</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                    if (this.checkCDATA(buf)) {</span>
<span class="fc" id="L735">                        this.scanPCData(buf);</span>
<span class="fc" id="L736">                        break;</span>
                    } else {
<span class="fc" id="L738">                        ch = this.scanWhitespace(buf);</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">                        if (ch != '&lt;') {</span>
<span class="fc" id="L740">                            this.unreadChar(ch);</span>
<span class="fc" id="L741">                            this.scanPCData(buf);</span>
<span class="fc" id="L742">                            break;</span>
                        }
                    }
                } else {
<span class="fc bfc" id="L746" title="All 4 branches covered.">                    if ((ch != '/') || this.ignoreLeadingAndTrailingWhitespace) {</span>
<span class="fc" id="L747">                        buf.setLength(0);</span>
                    }
<span class="fc bfc" id="L749" title="All 2 branches covered.">                    if (ch == '/') {</span>
<span class="fc" id="L750">                        this.unreadChar(ch);</span>
                    }
                    break;
                }
            }
        }
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (buf.length() == 0) {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">            while (ch != '/') {</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">                if (ch == '!') {</span>
<span class="fc" id="L759">                    ch = this.readChar();</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">                    if (ch != '-') {</span>
<span class="fc" id="L761">                        throw this.createUnexpectedInputException(&quot;Comment or Element&quot;);</span>
                    }
<span class="fc" id="L763">                    ch = this.readChar();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                    if (ch != '-') {</span>
<span class="fc" id="L765">                        throw this.createUnexpectedInputException(&quot;Comment or Element&quot;);</span>
                    }
<span class="fc" id="L767">                    this.skipComment();</span>
                } else {
<span class="fc" id="L769">                    this.unreadChar(ch);</span>
<span class="fc" id="L770">                    XmlElement child = this.createAnotherElement();</span>
<span class="fc" id="L771">                    this.scanElement(child);</span>
<span class="fc" id="L772">                    elt.addChild(child);</span>
                }
<span class="fc" id="L774">                ch = this.scanWhitespace();</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">                if (ch != '&lt;') {</span>
<span class="fc" id="L776">                    throw this.createUnexpectedInputException(&quot;&lt;&quot;);</span>
                }
<span class="fc" id="L778">                ch = this.readChar();</span>
            }
<span class="fc" id="L780">            this.unreadChar(ch);</span>
        } else {
<span class="fc bfc" id="L782" title="All 2 branches covered.">            if (this.ignoreLeadingAndTrailingWhitespace) {</span>
<span class="fc" id="L783">                elt.content = buf.toString().trim();</span>
            } else {
<span class="fc" id="L785">                elt.content = buf.toString();</span>
            }
        }
<span class="fc" id="L788">        ch = this.readChar();</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (ch != '/') {</span>
<span class="fc" id="L790">            throw this.createUnexpectedInputException(&quot;/&quot;);</span>
        }
<span class="fc" id="L792">        this.unreadChar(this.scanWhitespace());</span>

<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (!this.checkLiteral(name)) {</span>
<span class="fc" id="L795">            throw this.createUnexpectedInputException(name);</span>
        }
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (this.scanWhitespace() != '&gt;') {</span>
<span class="fc" id="L798">            throw this.createUnexpectedInputException(&quot;&gt;&quot;);</span>
        }
<span class="fc" id="L800">    }</span>

    // for debugging
//    private String readAll() {
//        StringBuilder b = new StringBuilder();
//        int c;
//        try {
//            while ((c = reader.read()) != -1) {
//                b.append((char) c);
//            }
//        } catch (IOException e) {
//            throw new UncheckedIOException(e);
//        }
//        return b.toString();
//    }

    /**
     * Resolves an entity. The name of the entity is read from the reader. The value
     * of the entity is appended to &lt;code&gt;buf&lt;/code&gt;.
     *
     * @param buf Where to put the entity value.
     */
    private void resolveEntity(StringBuilder buf) throws IOException {
<span class="fc" id="L823">        char ch = '\0';</span>
<span class="fc" id="L824">        StringBuilder keyBuf = new StringBuilder();</span>
        for (;;) {
<span class="fc" id="L826">            ch = this.readChar();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">            if (ch == ';') {</span>
<span class="fc" id="L828">                break;</span>
            }
<span class="fc" id="L830">            keyBuf.append(ch);</span>
        }
<span class="fc" id="L832">        String key = keyBuf.toString();</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">        if (key.charAt(0) == '#') {</span>
            try {
<span class="fc bfc" id="L835" title="All 2 branches covered.">                if (key.charAt(1) == 'x') {</span>
<span class="fc" id="L836">                    ch = (char) Integer.parseInt(key.substring(2), 16);</span>
                } else {
<span class="fc" id="L838">                    ch = (char) Integer.parseInt(key.substring(1), 10);</span>
                }
<span class="fc" id="L840">            } catch (NumberFormatException e) {</span>
<span class="fc" id="L841">                throw this.createExceptionUnknownEntity(key);</span>
<span class="fc" id="L842">            }</span>
<span class="fc" id="L843">            buf.append(ch);</span>
        } else {
<span class="fc" id="L845">            char[] value = (char[]) ENTITIES.get(key);</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L847">                throw this.createExceptionUnknownEntity(key);</span>
            }
<span class="fc" id="L849">            buf.append(value);</span>
        }
<span class="fc" id="L851">    }</span>

    /**
     * Pushes a character back to the read-back buffer.
     *
     * @param ch The character to push back.
     */
    private void unreadChar(char ch) {
<span class="fc" id="L859">        this.charReadTooMuch = ch;</span>
<span class="fc" id="L860">    }</span>

    /**
     * Creates a parse exception for when the end of the data input has been
     * reached.
     */
    private XmlParseException createExceptionUnexpectedEndOfData() {
<span class="fc" id="L867">        String msg = &quot;Unexpected end of data reached&quot;;</span>
<span class="fc" id="L868">        return new XmlParseException(this.name(), this.parserLineNr, msg);</span>
    }

    /**
     * Creates a parse exception for when the next character read is not the
     * character that was expected.
     *
     * @param charSet The set of characters (in human readable form) that was
     *                expected.
     */
    private XmlParseException createUnexpectedInputException(String charSet) {
<span class="fc" id="L879">        String msg = &quot;Expected: &quot; + charSet;</span>
<span class="fc" id="L880">        return new XmlParseException(this.name(), this.parserLineNr, msg);</span>
    }

    private XmlParseException createExceptionUnknownEntity(String name) {
<span class="fc" id="L884">        String msg = &quot;Unknown or invalid entity: &amp;&quot; + name + &quot;;&quot;;</span>
<span class="fc" id="L885">        return new XmlParseException(this.name(), this.parserLineNr, msg);</span>
    }

    private static Map&lt;String, char[]&gt; createEntities() {
<span class="fc" id="L889">        Map&lt;String, char[]&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L890">        map.put(&quot;amp&quot;, new char[] {'&amp;'});</span>
<span class="fc" id="L891">        map.put(&quot;quot&quot;, new char[] {'&quot;'});</span>
<span class="fc" id="L892">        map.put(&quot;apos&quot;, new char[] {'\''});</span>
<span class="fc" id="L893">        map.put(&quot;lt&quot;, new char[] {'&lt;'});</span>
<span class="fc" id="L894">        map.put(&quot;gt&quot;, new char[] {'&gt;'});</span>
<span class="fc" id="L895">        return map;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>